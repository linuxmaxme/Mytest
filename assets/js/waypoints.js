// Generated by CoffeeScript 1.6.2
/*
jQuery Waypoints - v2.0.2
Copyright (c) 2011-2013 Caleb Troughton
Dual licensed under the MIT license and GPL license.
https://github.com/imakewebthings/jquery-waypoints/blob/master/licenses.txt
*/
(function(){"use strict";var t=[].indexOf||function(t){for(var e=0,n=this.length;e<n;e++){if(e in this&&this[e]===t)return e}return-1},e=[].slice;(function(t,e){if(typeof define==="function"&&define.amd){return define("waypoints",["jquery"],function(n){return e(n,t)})}else{return e(t.jQuery,t)}})(this,function(n,r){var i,o,l,s,f,u,a,c,h,d,p,y,v,w,g,m;i=n(r);c=t.call(r,"ontouchstart")>=0;s={horizontal:{},vertical:{}};f=1;a={};u="waypoints-context-id";p="resize.waypoints";y="scroll.waypoints";v=1;w="waypoints-waypoint-ids";g="waypoint";m="waypoints";o=function(){function t(t){var e=this;this.$element=t;this.element=t[0];this.didResize=false;this.didScroll=false;this.id="context"+f++;this.oldScroll={x:t.scrollLeft(),y:t.scrollTop()};this.waypoints={horizontal:{},vertical:{}};t.data(u,this.id);a[this.id]=this;t.bind(y,function(){var t;if(!(e.didScroll||c)){e.didScroll=true;t=function(){e.doScroll();return e.didScroll=false};return r.setTimeout(t,n[m].settings.scrollThrottle)}});t.bind(p,function(){var t;if(!e.didResize){e.didResize=true;t=function(){n[m]("refresh");return e.didResize=false};return r.setTimeout(t,n[m].settings.resizeThrottle)}})}t.prototype.doScroll=function(){var t,e=this;t={horizontal:{newScroll:this.$element.scrollLeft(),oldScroll:this.oldScroll.x,forward:"right",backward:"left"},vertical:{newScroll:this.$element.scrollTop(),oldScroll:this.oldScroll.y,forward:"down",backward:"up"}};if(c&&(!t.vertical.oldScroll||!t.vertical.newScroll)){n[m]("refresh")}n.each(t,function(t,r){var i,o,l;l=[];o=r.newScroll>r.oldScroll;i=o?r.forward:r.backward;n.each(e.waypoints[t],function(t,e){var n,i;if(r.oldScroll<(n=e.offset)&&n<=r.newScroll){return l.push(e)}else if(r.newScroll<(i=e.offset)&&i<=r.oldScroll){return l.push(e)}});l.sort(function(t,e){return t.offset-e.offset});if(!o){l.reverse()}return n.each(l,function(t,e){if(e.options.continuous||t===l.length-1){return e.trigger([i])}})});return this.oldScroll={x:t.horizontal.newScroll,y:t.vertical.newScroll}};t.prototype.refresh=function(){var t,e,r,i=this;r=n.isWindow(this.element);e=this.$element.offset();this.doScroll();t={horizontal:{contextOffset:r?0:e.left,contextScroll:r?0:this.oldScroll.x,contextDimension:this.$element.width(),oldScroll:this.oldScroll.x,forward:"right",backward:"left",offsetProp:"left"},vertical:{contextOffset:r?0:e.top,contextScroll:r?0:this.oldScroll.y,contextDimension:r?n[m]("viewportHeight"):this.$element.height(),oldScroll:this.oldScroll.y,forward:"down",backward:"up",offsetProp:"top"}};return n.each(t,function(t,e){return n.each(i.waypoints[t],function(t,r){var i,o,l,s,f;i=r.options.offset;l=r.offset;o=n.isWindow(r.element)?0:r.$element.offset()[e.offsetProp];if(n.isFunction(i)){i=i.apply(r.element)}else if(typeof i==="string"){i=parseFloat(i);if(r.options.offset.indexOf("%")>-1){i=Math.ceil(e.contextDimension*i/100)}}r.offset=o-e.contextOffset+e.contextScroll-i;if(r.options.onlyOnScroll&&l!=null||!r.enabled){return}if(l!==null&&l<(s=e.oldScroll)&&s<=r.offset){return r.trigger([e.backward])}else if(l!==null&&l>(f=e.oldScroll)&&f>=r.offset){return r.trigger([e.forward])}else if(l===null&&e.oldScroll>=r.offset){return r.trigger([e.forward])}})})};t.prototype.checkEmpty=function(){if(n.isEmptyObject(this.waypoints.horizontal)&&n.isEmptyObject(this.waypoints.vertical)){this.$element.unbind([p,y].join(" "));return delete a[this.id]}};return t}();l=function(){function t(t,e,r){var i,o;r=n.extend({},n.fn[g].defaults,r);if(r.offset==="bottom-in-view"){r.offset=function(){var t;t=n[m]("viewportHeight");if(!n.isWindow(e.element)){t=e.$element.height()}return t-n(this).outerHeight()}}this.$element=t;this.element=t[0];this.axis=r.horizontal?"horizontal":"vertical";this.callback=r.handler;this.context=e;this.enabled=r.enabled;this.id="waypoints"+v++;this.offset=null;this.options=r;e.waypoints[this.axis][this.id]=this;s[this.axis][this.id]=this;i=(o=t.data(w))!=null?o:[];i.push(this.id);t.data(w,i)}t.prototype.trigger=function(t){if(!this.enabled){return}if(this.callback!=null){this.callback.apply(this.element,t)}if(this.options.triggerOnce){return this.destroy()}};t.prototype.disable=function(){return this.enabled=false};t.prototype.enable=function(){this.context.refresh();return this.enabled=true};t.prototype.destroy=function(){delete s[this.axis][this.id];delete this.context.waypoints[this.axis][this.id];return this.context.checkEmpty()};t.getWaypointsByElement=function(t){var e,r;r=n(t).data(w);if(!r){return[]}e=n.extend({},s.horizontal,s.vertical);return n.map(r,function(t){return e[t]})};return t}();d={init:function(t,e){var r;if(e==null){e={}}if((r=e.handler)==null){e.handler=t}this.each(function(){var t,r,i,s;t=n(this);i=(s=e.context)!=null?s:n.fn[g].defaults.context;if(!n.isWindow(i)){i=t.closest(i)}i=n(i);r=a[i.data(u)];if(!r){r=new o(i)}return new l(t,r,e)});n[m]("refresh");return this},disable:function(){return d._invoke(this,"disable")},enable:function(){return d._invoke(this,"enable")},destroy:function(){return d._invoke(this,"destroy")},prev:function(t,e){return d._traverse.call(this,t,e,function(t,e,n){if(e>0){return t.push(n[e-1])}})},next:function(t,e){return d._traverse.call(this,t,e,function(t,e,n){if(e<n.length-1){return t.push(n[e+1])}})},_traverse:function(t,e,i){var o,l;if(t==null){t="vertical"}if(e==null){e=r}l=h.aggregate(e);o=[];this.each(function(){var e;e=n.inArray(this,l[t]);return i(o,e,l[t])});return this.pushStack(o)},_invoke:function(t,e){t.each(function(){var t;t=l.getWaypointsByElement(this);return n.each(t,function(t,n){n[e]();return true})});return this}};n.fn[g]=function(){var t,r;r=arguments[0],t=2<=arguments.length?e.call(arguments,1):[];if(d[r]){return d[r].apply(this,t)}else if(n.isFunction(r)){return d.init.apply(this,arguments)}else if(n.isPlainObject(r)){return d.init.apply(this,[null,r])}else if(!r){return n.error("jQuery Waypoints needs a callback function or handler option.")}else{return n.error("The "+r+" method does not exist in jQuery Waypoints.")}};n.fn[g].defaults={context:r,continuous:true,enabled:true,horizontal:false,offset:0,triggerOnce:false};h={refresh:function(){return n.each(a,function(t,e){return e.refresh()})},viewportHeight:function(){var t;return(t=r.innerHeight)!=null?t:i.height()},aggregate:function(t){var e,r,i;e=s;if(t){e=(i=a[n(t).data(u)])!=null?i.waypoints:void 0}if(!e){return[]}r={horizontal:[],vertical:[]};n.each(r,function(t,i){n.each(e[t],function(t,e){return i.push(e)});i.sort(function(t,e){return t.offset-e.offset});r[t]=n.map(i,function(t){return t.element});return r[t]=n.unique(r[t])});return r},above:function(t){if(t==null){t=r}return h._filter(t,"vertical",function(t,e){return e.offset<=t.oldScroll.y})},below:function(t){if(t==null){t=r}return h._filter(t,"vertical",function(t,e){return e.offset>t.oldScroll.y})},left:function(t){if(t==null){t=r}return h._filter(t,"horizontal",function(t,e){return e.offset<=t.oldScroll.x})},right:function(t){if(t==null){t=r}return h._filter(t,"horizontal",function(t,e){return e.offset>t.oldScroll.x})},enable:function(){return h._invoke("enable")},disable:function(){return h._invoke("disable")},destroy:function(){return h._invoke("destroy")},extendFn:function(t,e){return d[t]=e},_invoke:function(t){var e;e=n.extend({},s.vertical,s.horizontal);return n.each(e,function(e,n){n[t]();return true})},_filter:function(t,e,r){var i,o;i=a[n(t).data(u)];if(!i){return[]}o=[];n.each(i.waypoints[e],function(t,e){if(r(i,e)){return o.push(e)}});o.sort(function(t,e){return t.offset-e.offset});return n.map(o,function(t){return t.element})}};n[m]=function(){var t,n;n=arguments[0],t=2<=arguments.length?e.call(arguments,1):[];if(h[n]){return h[n].apply(null,t)}else{return h.aggregate.call(null,n)}};n[m].settings={resizeThrottle:100,scrollThrottle:30};return i.load(function(){return n[m]("refresh")})})}).call(this);;




// REVOLUTION SLIDER
jQuery(document).ready(function() {
"use strict";
	var ajaxRevslider = function(obj) {
	
		// obj.type : Post Type
		// obj.id : ID of Content to Load
		// obj.aspectratio : The Aspect Ratio of the Container / Media
		// obj.selector : The Container Selector where the Content of Ajax will be injected. It is done via the Essential Grid on Return of Content
		
		var content = "";

		data = {};
		
		data.action = 'revslider_ajax_call_front';
		data.client_action = 'get_slider_html';
		data.token = '9e44448a85';
		data.type = obj.type;
		data.id = obj.id;
		data.aspectratio = obj.aspectratio;
		
		// SYNC AJAX REQUEST
		jQuery.ajax({
			type:"post",
			url:"#",
			dataType: 'json',
			data:data,
			async:false,
			success: function(ret, textStatus, XMLHttpRequest) {
				if(ret.success == true)
					content = ret.data;								
			},
			error: function(e) {
				console.log(e);
			}
		});
		
		 // FIRST RETURN THE CONTENT WHEN IT IS LOADED !!
		 return content;						 
	};
	
	// CUSTOM AJAX FUNCTION TO REMOVE THE SLIDER
	var ajaxRemoveRevslider = function(obj) {
		return jQuery(obj.selector+" .rev_slider").revkill();
	};

	// EXTEND THE AJAX CONTENT LOADING TYPES WITH TYPE AND FUNCTION
	var extendessential = setInterval(function() {
		if (jQuery.fn.tpessential != undefined) {
			clearInterval(extendessential);
			if(typeof(jQuery.fn.tpessential.defaults) !== 'undefined') {
				jQuery.fn.tpessential.defaults.ajaxTypes.push({type:"revslider",func:ajaxRevslider,killfunc:ajaxRemoveRevslider,openAnimationSpeed:0.3});   
				// type:  Name of the Post to load via Ajax into the Essential Grid Ajax Container
				// func: the Function Name which is Called once the Item with the Post Type has been clicked
				// killfunc: function to kill in case the Ajax Window going to be removed (before Remove function !
				// openAnimationSpeed: how quick the Ajax Content window should be animated (default is 0.3)
			}
		}
	},30);
});




/******************************************
	-	PREPARE PLACEHOLDER FOR SLIDER	-
******************************************/

var setREVStartSize = function() {
"use strict";
    var tpopt = new Object();
    tpopt.startwidth = 1140;
    tpopt.startheight = 500;
    tpopt.container = jQuery('#rev_slider_1_1');
    tpopt.fullScreen = "off";
    tpopt.forceFullWidth = "off";

    tpopt.container.closest(".rev_slider_wrapper").css({
        height: tpopt.container.height()
    });
    tpopt.width = parseInt(tpopt.container.width(), 0);
    tpopt.height = parseInt(tpopt.container.height(), 0);
    tpopt.bw = tpopt.width / tpopt.startwidth;
    tpopt.bh = tpopt.height / tpopt.startheight;
    if (tpopt.bh > tpopt.bw) tpopt.bh = tpopt.bw;
    if (tpopt.bh < tpopt.bw) tpopt.bw = tpopt.bh;
    if (tpopt.bw < tpopt.bh) tpopt.bh = tpopt.bw;
    if (tpopt.bh > 1) {
        tpopt.bw = 1;
        tpopt.bh = 1
    }
    if (tpopt.bw > 1) {
        tpopt.bw = 1;
        tpopt.bh = 1
    }
    tpopt.height = Math.round(tpopt.startheight * (tpopt.width / tpopt.startwidth));
    if (tpopt.height > tpopt.startheight && tpopt.autoHeight != "on") tpopt.height = tpopt.startheight;
    if (tpopt.fullScreen == "on") {
        tpopt.height = tpopt.bw * tpopt.startheight;
        var cow = tpopt.container.parent().width();
        var coh = jQuery(window).height();
        if (tpopt.fullScreenOffsetContainer != undefined) {
            try {
                var offcontainers = tpopt.fullScreenOffsetContainer.split(",");
                jQuery.each(offcontainers, function(e, t) {
                    coh = coh - jQuery(t).outerHeight(true);
                    if (coh < tpopt.minFullScreenHeight) coh = tpopt.minFullScreenHeight
                })
            } catch (e) {}
        }
        tpopt.container.parent().height(coh);
        tpopt.container.height(coh);
        tpopt.container.closest(".rev_slider_wrapper").height(coh);
        tpopt.container.closest(".forcefullwidth_wrapper_tp_banner").find(".tp-fullwidth-forcer").height(coh);
        tpopt.container.css({
            height: "100%"
        });
        tpopt.height = coh;
    } else {
        tpopt.container.height(tpopt.height);
        tpopt.container.closest(".rev_slider_wrapper").height(tpopt.height);
        tpopt.container.closest(".forcefullwidth_wrapper_tp_banner").find(".tp-fullwidth-forcer").height(tpopt.height);
    }

};




/* CALL PLACEHOLDER */

setREVStartSize();
var tpj = jQuery;
tpj.noConflict();
var revapi1;

tpj(document).ready(function() {
"use strict";
    if (tpj('#rev_slider_1_1').revolution == undefined) {
        revslider_showDoubleJqueryError('#rev_slider_1_1');
    } else {
        revapi1 = tpj('#rev_slider_1_1').show().revolution({
            dottedOverlay: "none",
            delay: 6000,
            startwidth: 1140,
            startheight: 500,
            hideThumbs: 200,
            thumbWidth: 100,
            thumbHeight: 50,
            thumbAmount: 3,
            simplifyAll: "off",
            navigationType: "bullet",
            navigationArrows: "solo",
            navigationStyle: "round",
            touchenabled: "on",
            onHoverStop: "on",
            nextSlideOnWindowFocus: "off",
            swipe_threshold: 0.7,
            swipe_min_touches: 1,
            drag_block_vertical: false,
            keyboardNavigation: "on",
            navigationHAlign: "center",
            navigationVAlign: "bottom",
            navigationHOffset: 0,
            navigationVOffset: 20,
            soloArrowLeftHalign: "left",
            soloArrowLeftValign: "center",
            soloArrowLeftHOffset: 20,
            soloArrowLeftVOffset: 0,
            soloArrowRightHalign: "right",
            soloArrowRightValign: "center",
            soloArrowRightHOffset: 20,
            soloArrowRightVOffset: 0,
            shadow: 0,
            fullWidth: "on",
            fullScreen: "off",
            spinner: "spinner4",
            stopLoop: "off",
            stopAfterLoops: -1,
            stopAtSlide: -1,
            shuffle: "off",
            autoHeight: "off",
            forceFullWidth: "off",
            hideTimerBar: "on",
            hideThumbsOnMobile: "off",
            hideNavDelayOnMobile: 1500,
            hideBulletsOnMobile: "off",
            hideArrowsOnMobile: "off",
            hideThumbsUnderResolution: 0,
            hideSliderAtLimit: 0,
            hideCaptionAtLimit: 0,
            hideAllCaptionAtLilmit: 0,
            startWithSlide: 0
        });
    }

});




/*
 * Simple script for building canvas point
 * arc connector between 2 points
 * 
 * markup :
 * 
 * container must have position relative rule
 * and css class : point-connector
 * source point must have css class : Points.$start
 * target point must have css class : Points.$end
 *         
 * @author jason.xie@victheme.com
 */
(function($) {
  $.fn.pointConnect = function() {

    return this.each(function() {
      
      var mainCanvas = $('<canvas class="pointer-canvas" />');

      mainCanvas
        .attr('width', $(this).width())
        .attr('height', $(this).height())
        .css({
          zIndex: 1,
          position: 'absolute',
          left:  0,
          top: 0
        })
        .prependTo($(this));
      
      var Points = {
          $el: $(this),
          $items: $(this).find('.history-content'),
          ctx: mainCanvas.get(0).getContext('2d'),
          point: {}
      };
      
      $(this).css('position', 'relative');

      Points.$items.each(function(key, element) {

        Points.$start = $(this).find('.startpoint'),
        Points.$end = Points.$items.eq(key + 1).find('.endpoint');
        
        // Skip if no valid Points.$end found.
        if (Points.$end.length == 0 || Points.$start.length == 0) {
          return true;
        }

        Points.$end.css({
          display: 'inline-block',
          height: '20px',
          width: '20px',
          margin: '0 30px'
        });

        $(this).css({
          zIndex: 2,
          position: 'relative'
        });

        Points.point[key] = {
          start: {
            x: Points.$start.offset().left - mainCanvas.offset().left,
            y: Points.$start.offset().top - mainCanvas.offset().top
          },
          end: {
            x: Points.$end.offset().left - mainCanvas.offset().left,
            y: Points.$end.offset().top - mainCanvas.offset().top
          },
          control: {
            x: 0,
            y: 0
          },
          curve: {
            x: $(this).data('curve-x') || Points.$el.data('curvex') || 0,
            y: $(this).data('curve-y') || Points.$el.data('curvey') || 100
          },
          offset: {
            start: {
              x: $(this).data('offset-start-x') || Points.$el.data('startx') || Points.$start.width() / 2,
              y: $(this).data('offset-start-y') || Points.$el.data('starty') || Points.$start.height() / 2
            },
            end: {
              x: $(this).data('offset-end-x') || Points.$el.data('endx') || Points.$end.width() / 2,
              y: $(this).data('offset-end-y') || Points.$el.data('endy') || Points.$end.height() / 2
            }
          },
          gradient: {
            one : $(this).data('gradientone') || Points.$el.data('gradientone') || '#ff6c00',
            two : $(this).data('gradienttwo') || Points.$el.data('gradienttwo') || '#1c2232'
          },
          line: {
            width: $(this).data('linewidth') || Points.$el.data('linewidth') || 10,
            type: $(this).data('linetype') || Points.$el.data('linetype') || 'round'
          }
        };

        Points.point[key].start.x += Points.point[key].offset.start.x;
        Points.point[key].start.y += Points.point[key].offset.start.y;

        Points.point[key].end.x += Points.point[key].offset.end.x;
        Points.point[key].end.y += Points.point[key].offset.end.y;

        Points.point[key].control.x = Points.point[key].start.x + Points.point[key].curve.x;
        Points.point[key].control.y = Points.point[key].start.y + Points.point[key].curve.y;

        Points.ctx.beginPath();

        Points.ctx.moveTo(
          Points.point[key].start.x,
          Points.point[key].start.y
        );

        Points.ctx.quadraticCurveTo(
          Points.point[key].control.x,
          Points.point[key].control.y,
          Points.point[key].end.x,
          Points.point[key].end.y
        );

        Points.ctx.lineWidth = Points.point[key].line.width;

        // Dashed mode
        Points.ctx.lineCap = Points.point[key].line.type;
        Points.ctx.miterLimit = Points.point[key].width;

        if (typeof Points.ctx.setLineDash !== 'undefined' ) {
          Points.ctx.setLineDash([10,20]);
        }

        else if (typeof Points.ctx.mozDash !== 'undefined' ) {
          Points.ctx.mozDash = [10,20];
        }

        // Gradient
        Points.grd = Points.ctx.createLinearGradient(0, Points.point[key].start.x, mainCanvas.width(), Points.point[key].end.x);
        Points.grd.addColorStop(0, Points.point[key].gradient.one);
        Points.grd.addColorStop(0.2, Points.point[key].gradient.one);
        Points.grd.addColorStop(0.8, Points.point[key].gradient.two);
        Points.grd.addColorStop(1, Points.point[key].gradient.two);
        
        // line color
        Points.ctx.strokeStyle = Points.grd;
        Points.ctx.stroke();

      });

      // Destroy Points
      Points = null

      // Destroy references
      delete Points;
      delete mainCanvas;
    }); 
  };

  if ($('#page').length && $('#page').hasClass('animsition')) {
    $(window)
      .on('animsitionPageIn', function() {

        $('.pointer-canvas').remove();
        $('.point-connector').pointConnect();

        $(window)
          .on('resize sortupdate', function() {
            $('.pointer-canvas').remove();
            $('.point-connector').pointConnect();
          });

      });
  } else {
	
    $(window)
      .on('load resize sortupdate', function () {
        $('.pointer-canvas').remove();
        $('.point-connector').pointConnect();
      });
  }
  
})(jQuery);;




var addComment={moveForm:function(a,b,c,d){"use strict";var e,f=this,g=f.I(a),h=f.I(c),i=f.I("cancel-comment-reply-link"),j=f.I("comment_parent"),k=f.I("comment_post_ID");if(g&&h&&i&&j){f.respondId=c,d=d||!1,f.I("wp-temp-form-div")||(e=document.createElement("div"),e.id="wp-temp-form-div",e.style.display="none",h.parentNode.insertBefore(e,h)),g.parentNode.insertBefore(h,g.nextSibling),k&&d&&(k.value=d),j.value=b,i.style.display="",i.onclick=function(){var a=addComment,b=a.I("wp-temp-form-div"),c=a.I(a.respondId);if(b&&c)return a.I("comment_parent").value="0",b.parentNode.insertBefore(c,b),b.parentNode.removeChild(b),this.style.display="none",this.onclick=null,!1};try{f.I("comment").focus()}catch(l){}return!1}},I:function(a){return document.getElementById(a)}};;




/*
 * Simple script for creating an element
 * with canvas and image. the advantages
 * is this will enable themer to use single
 * image that is trully recolorable via js
 * or PHP
 * 
 * Only use this for images that has shapes that
 * is not possible to reproduce with normal HTML
 * + CSS method.
 * 
 * Parameter needed :
 *  data-mask = the image url to act as the mask
 *  data-background = the background color to fill the mask
 *  
 * Must be built using canvas element with markup :
 * 
 * <canvas class="masked-element" data-mask="" data-background=""></canvas>
 *  
 * Known downfall :
 * 1. The masking image size must be as close as possible to
 *    the masked element size or jagged image will be produced.
 *    
 *    
 * @author jason.xie@victheme.com
 */
(function($) {
"use strict"; 
   $.fn.maskingElements = function() {

     return this.each(function() {
       
       // Just force to do retina all the way, it won't be much different since the image most likely to be very small
       var ratio = 2,
           canvas = $('<canvas />');
       
       // Resize the canvas dimension based on 
       // viewport width and pixel ratio
       canvas
         .attr('width', $(this).width() * ratio + 'px')
         .attr('height', $(this).height() * ratio + 'px')
         .width($(this).width() * ratio)
         .height($(this).height() * ratio)
         .appendTo($('#vc-inline-frame'));
       
       // Build the line configuration object
       var _Button = {
             element: $(this),
             width: $(this).width() * ratio,
             height: $(this).height() * ratio,
             background: $(this).data('background'),
             ctx: canvas.get(0).getContext('2d')
           };
       
       _Button.maskObj = new Image();
       _Button.maskObj.src = _Button.element.data('mask');
       _Button.maskObj.width = _Button.element.width() * ratio;
       _Button.maskObj.height = _Button.element.height() * ratio;
  
       $(_Button.maskObj).one('load', function() { 
         
         // Fake the draw up to get masking data only.
         _Button.ctx.drawImage(_Button.maskObj, 0, 0, _Button.width, _Button.height);
         _Button.maskData = _Button.ctx.getImageData(0, 0, _Button.width, _Button.height);
         _Button.ctx.clearRect(0, 0, _Button.width, _Button.height);
         
         // Apply the background color
         _Button.ctx.rect(0, 0, _Button.width, _Button.height);
         _Button.ctx.fillStyle = _Button.background;
         _Button.ctx.fill();
         
         // Get the image data for alteration
         _Button.imageData = _Button.ctx.getImageData(0, 0, _Button.width, _Button.height);
  
         // Apply the masking
         for (var i = 0; i < _Button.imageData.data.length; i += 4) {
           _Button.imageData.data[i + 3] = _Button.maskData.data[i + 3];
         }
  
         _Button.ctx.putImageData(_Button.imageData, 0, 0);
         _Button.ctx.shadowBlur = 4;
         
         _Button.Image = new Image();
         _Button.Image.src = _Button.ctx.canvas.toDataURL();
         
         _Button.element.find('img').remove();
         _Button.element.prepend(_Button.Image);
         
         _Button.element.removeClass('masked-elements');
       });
     
     });

   }   
 
})(jQuery);


jQuery(document).ready(function($) {
"use strict";
  
  $(window).on('load', function() {
    
    setTimeout(function() {
      $('[data-toggle="masked-elements"]').maskingElements().removeAttr('data-toggle');
    }, 100);
  
  });
  
  
  $(document).on('ajaxComplete', function() {
    setTimeout(function() {
      $('[data-toggle="masked-elements"]').maskingElements().removeAttr('data-toggle');
    }, 100);
  });
  
});




/*
 * Simple script for indenting element
 * 
 * @experimental state!
 * @known bug, somehow offset is returning the same position for all element?
 * @author jason.xie@victheme.com
 */
jQuery(document).ready(function($) {
"use strict";  
  
  $.fn.VTCoreInlineIndent = function() {
    var _el = {
        float  : $('.float-target'),
        indent : $('.indent-target > *'),
    };
  
    _el.floatData = {
        height    : _el.float.height(),
        marginTop : _el.indent.eq(0).position().top + _el.indent.eq(0).height()
    };
    
    _el.floatData.endPosition = _el.float.offset().top + _el.floatData.height + _el.floatData.marginTop;
    
    _el.actions = {
        indentElement : function() {
          
          _el.indent.filter(':gt(0)').each(function(key, val) {
            var self = $(this);
            
            if (_el.indent.eq(key).offset().top < _el.floatData.endPosition) {
              self.addClass('col-sm-10 nopadding');
            }
            else {
              self.addClass('clearboth');
            }
          });
          _el.float.css('marginTop', _el.floatData.marginTop);
        },
        resetElement : function() {
          _el.indent.removeClass('col-sm-10 nopadding clearboth');
          _el.float.css('marginTop', '');
        }
    }
    
    return _el.actions;
  }
   
  if ($('.float-target').length != 0 && $('.indent-target > *').length != 0) { 
    $(window)
      .on('load.indentel pageready.indentel resize_end.indentel', function() {
        setTimeout(function() {
          $.fn.VTCoreInlineIndent().indentElement();
        }, 100);
      });
  }

});




/*
 * 
 * Main controller file for controlling Portfolio
 * teaser listing
 * 
 * @todo : Force all to respect the viewport setting
 * @todo : mark the original viewport
 * @todo : refactor this mess!
 * 
 * @author jason.xie@victheme.com
 */
(function ($) {
 
  "use strict";
   
  /**
   * Function for attaching the isotope function
   * to a button. This will also invoke the filtering
   * mechanism
   * 
   * This function will assume that the isotope is
   * already initialized and just perform the filtering
   * for the items.
   */
  $.fn.VTCorePortfolioDoIsotope = function() {
    var self = this,
        source = $('.isotope-sources.portfolio[data-target=' + self.attr('data-target') + ']'),
        target = $('.isotope-target.portfolio[data-target=' + self.attr('data-target') + ']'),
        sort = '[data-id*=' + self.attr('data-id') + ']';

    // Allow everything
    if (self.attr('data-id') == '*') {
      sort = '*';
    }

    // Remove the active class
    source
      .find('li')
      .removeClass('active');
   
    // Set the new active class
    self.parent('li').addClass('active');

    // Invoke isotope filtering
    target
      .isotope({
        filter: sort
      });
  }
  
  
  /**
   * Window events
   */
  $(window)
    .on('resize_end', function() {
      
      setTimeout(function() {
        
        // Force to relayout again to fix equal heights
        $('.isotope-target.portfolio-initialized').isotope('layout');
        
      }, 600);
      
    })
    .on('load', function() {
      
      // Initialize isotope
      $('.isotope-target.portfolio:not(.portfolio-initialized)')
        .isotope({
          itemSelector: '.isotope-item',
          transitionDuration: '0.7s',
          layoutMode : 'fitRows',
          fitRows: {
            equalheight: true
          },
          resizeDelay: 600
        })
        .addClass('portfolio-initialized');
      
    });
  
  
  $(document)
  
    .on('layoutComplete', function(isoInstance, item) {       

      if ( $.isFunction($.inviewport) ) {
        $(item.element).find('.scroll-animated:in-viewport').removeClass('scroll-animated').addClass('animated');
      }
      
      if ( $.isFunction($.fn.VTCoreAspectRatio) ) {
        $(item.element).find('[data-aspect="true"]').VTCoreAspectRatio();
      }
      
      if ( $.isFunction($.fn.vertCentInit) ) {
        $(item.element).find('.vertical-target').stop();
        $(item.element).find('.vertical-center').vertCentInit();
      }

    })
    
    // Binding the isotope click filter
    .on('click', '.portfolio-source.isotope-sources .term-link', function(e) {
                
      // This must be before anything else to avoid page change if js is broken
      e.preventDefault();
      
      if ($(this).attr('data-id') == '*' || $(this).hasClass('btn-ajax') != true) {
        $(this).VTCorePortfolioDoIsotope();
      }
    })
    
    
    // Binding the grid or list selector
    .on('click', '.portfolio-source.isotope-sources .grid-mode', function(e) {
      
        e.preventDefault();
        
        var self = $(this);
        
        $('.isotope-target[data-target=' + self.attr('data-target') + ']')
          .removeClass('grid')
          .removeClass('list')
          .addClass(self.attr('data-class'))
          .isotope('layout');
        
        // Reset the active class
        $('.grid-active').removeClass('grid-active');
        
        // Add the active class to the new element
        self.parent().addClass('grid-active');
    })
      
    // Hooking into vtcore ajax framework by attaching our
    // snippet into the ajaxComplete events
    .on('ajaxComplete', function(event, xhr, settings) {
      
      // Initialize isotope on newly fetched content via ajax
      $('.isotope-target.portfolio:not(.portfolio-initialized)')
        .isotope({
          itemSelector: '.isotope-item',
          transitionDuration: '0.7s',
          layoutMode : 'fitRows'
        })
        .addClass('portfolio-initialized');
      
      if (typeof settings.marker != 'undefined'
          && typeof settings.marker.mode != 'undefined'
          && typeof settings.marker.target != 'undefined'
          && settings.marker.mode == 'portfolio') {

       
        // Updates all button filters, this is needed for sane ajax stopping!.
        var filters = $(settings.marker.target).data('ajax-value');

        $(settings.marker.target).closest('.portfolio-source.isotope-sources').find('.btn-ajax').each(function() {
          var self = $(this), valuedata = self.data('ajax-value');       
          valuedata.filter = filters.filter;
          self.data('ajax-value', valuedata);
        });
        

        var self = $(settings.marker.container),
            AjaxData = $.fn.VTCoreProcessAjaxResponse(xhr.responseText),
            objectQueue = $({});

        AjaxData.content && AjaxData.content.action && $.each(AjaxData.content.action, function (key, data) {

          if (data.mode == 'portfolio-isotope-append' && data.content) {

            var items = $(data.content.replace(/(\r\n|\n|\r)/gm, ""));

            // Queue all ajax results
            items.each(function(index, element) {

              var item = $(this);

              // try not to append multiple duplicate item, this is not ideal need better solution!
              if (item.attr('id') && self.find('#' + item.attr('id')).length) {
                return true;
              }

              if (item.find('img').length) {
                item.find('img').each(function (key, el) {
                  var image = $(this);
                  objectQueue.queue(function (next) {
                    image.on('load', function() {
                      next();
                    });
                  });
                });
              }

              if (items.length -1 == index) {
                objectQueue.queue(function(next) {
                  self.append(items).isotope('addItems', items);
                  next();

                });

                objectQueue.queue(function(next) {
                  $(settings.marker.target).VTCorePortfolioDoIsotope();
                  next();
                });

                objectQueue.queue(function(next) {
                  setTimeout(function() {
                    self.isotope('layout');
                  }, 1000);
                  next();
                });

                // Process the queued item
                objectQueue.dequeue();
              }

            });
          }

          if (data.mode == 'portfolio-filter') {
            $(settings.marker.target).VTCorePortfolioDoIsotope();
          }
        });
      }
      
    });
  
})(jQuery);




/*
 * Generic javascript for processing json returned
 * by VTCore Elements. This class must be used in
 * conjunction with VTCore_Ajax API Rules.
 * 
 * Element that will invoke the ajax calls must have
 * .btn-ajax class and place all the data to be 
 * passed into PHP via HTML data-* attributes.
 * 
 * required data :
 * 
 *    ajax-mode : post | data | both | trigger | value
 *                post    - this mode will retrieve the parent element (must be a form) post data, serialized
 *                          serialized it and convert into an url parameters
 *                data    - this mode will just retrieve the element html5 data-* attributes, serialized it and
 *                          convert it into url parameters
 *                both    - this mode will retrieve both parent element post and element data attributes,
 *                          merged them, serialized it and convert to url parameters.
 *                trigger - this mode will retrieve the data-ajax-trigger on selected target
 *                value   - this mode will retrieve the value of the selected target using jQuery .val() method.
 *
 *    ajax-target : CSS selector - recommended to use id such as '#someid', this is the target parent
 *                  used to determine the target point for fetching post or modifying the content
 *
 *    ajax-loading-text : string - this string will be shown in the button or input submit element when
 *                                 an ajax event is processing
 *
 *    ajax-object : valid PHP object name - this object will be invoked when an ajax request is made, it must
 *                                          be a valid php object that also been registered via autoloader
 *                                          the script will not attempt to look for the class file, it will
 *                                          just initializes the class.
 *
 *    ajax-action : the nonce key - by default it will use 'vtcore-ajax-framework' unless you have change
 *                                  the default nonce key, no need to change this.
 *
 *    ajax-value : the custom value that you can pass from ajax to processor, this is usefull to mark a button
 *                 like the triggering element name
 *
 *    ajax-queue : array and optional - you can use queueing system to queue the ajax process and pass the value
 *                 name to act as triggering marker one by one in the array. The array will be converted into
 *                 a json object via VTCore_Html base data-* processor.
 *                 
 *    ajax-group : group of button that will be disabled during ajax queue process
 *                 
 *                 
 *  @author jason.xie@victheme.com
 */


(function($) {
"use strict"; 
 
  var requests = [];
  
  /**
   * Fix for serialized array ignoring
   * disabled element
   */
  var proxy = $.fn.serializeArray;
  $.fn.serializeArray = function(){
      var inputs = this.find(':disabled');
      inputs.prop('disabled', false);
      var serialized = proxy.apply( this, arguments );
      inputs.prop('disabled', true);
      return serialized;
  };
  
  /**
   * Ajax queue manager
   */
  var ajaxManager = {
     addReq:  function(opt) {
       requests.push(opt);
     },
     removeReq:  function(opt) {
       if ( $.inArray(opt, requests) > -1 ) {
         requests.splice($.inArray(opt, requests), 1);
       }
     },
     run: function(callback) {

       var self = this,
           oriSuc;

       if ( requests.length ) {
         oriSuc = requests[0].complete;

         requests[0].complete = function() {
            if( typeof(oriSuc) === 'function' ) oriSuc();
            // @experimental removed to avoid ajax calling same request more than once bug
            //requests.shift();
            
            self.run.call(self, callback);
         };   

         $.ajax(requests[0]);
         requests.shift();
       } 
       
       else {
         self.tid = setTimeout(function() {
            
           self.run.call(self, callback);
            
            if (callback && typeof callback == 'function') {
              callback();
            }
            
            self.stop();
            
         }, 1000);
         
       }
     },
     stop:  function() {
         requests = [];
         clearTimeout(this.tid);
     }
   };
   
  
	/**
	 * Function for translating the VTCore_Ajax Server side api into 
	 * javascript sets of commands.
	 */
	$.fn.VTCoreProcessAjaxResponse = function(response) {
    var data = response.split('<---JSON-STARTS---->'),
		response = [];  
    
    if (data[0] != ' ') {
    	response.error = '<div clas="alert alert-danger">' + data[0] + '</div>';
    }
    
    response.content = $.parseJSON(data[1]);
    
    return response;	
	};
		
	
	/**
	 * Processing the returned ajax data
	 * 
	 * User can define this variables in the json data returned :
	 * content 				 = array of contents
	 * 		action			 = array All the actions that will be processed
	 * 			mode			 = string error|replace|append|prepend|delete	
	 * 			target		 = string the target css id or class to perform the action mode
	 * 
	 */
	$.fn.VTCoreProcessAjaxReturn = function(response, status) {
	  
	  if (typeof response.content == 'undefined' || response.content == null) {
	    return false;
	  }
	  
		if (typeof response.content.errortarget != 'undefined'
				&& typeof response.error != 'undefined') {
			$(response.content.errortarget).prepend(response.error);
		}
		
    $.each(response.content.action, function(key, data) {
      switch (data.mode) {   
      	case 'error' :
      		$(data.target).append(data.content);
        break;
        
      	case 'replace' :
      		$(data.target).replaceWith(data.content);
        break;
        
        case 'html' :
          $(data.target).html(data.content);
        break;
        
      	case 'append' :
          $(data.target).append(data.content);
        break;
        
        case 'prepend' :
          $(data.target).prepend(data.content);               
        break;
        
        case 'delete' :
        	$(data.target).remove();
        break;
        
        case 'empty' :
          $(data.target).empty();
        break;
        
        case 'text' :
          $(data.target).html(data.content);
        break;
        
        case 'callback' :
          (new Function(data.content))();
        break;
        
        case 'data' :
          if (data.merge) {
            data.content = $.extend($(data.target).data(data.key), data.content);
          }
          $(data.target).data(data.key, data.content);
        break;
        
        case 'addClass' :
          $(data.target).addClass(data.content);
        break;  
        
        case 'removeClass' :
          $(data.target).removeClass(data.content);
        break;
      }
    });
	}
	
	
	$.fn.VTCoreInvokeAjax = function(e) {
	  
    // Prevents submission or link default event
    e.preventDefault();
    
    // Allow other plugin to stop the ajax via
    // data-ajax-stop="true"
    if ($(this).data('ajax-stop') == true) {
      return false;
    }
    
    // All the data parameter must be attached as HTML5 data
    // so it can be passed on to the PHP server side script.
    var ajaxMode = $(this).data('ajax-mode'),
        btn = $(this),
        text = (btn.is('input')) ? btn.val() : btn.html(),
        target = $(btn.data('ajax-target')),
        replacement = btn.data('ajax-loading-text'),
        queue = btn.data('ajax-queue'),
        marker = btn.data('ajax-marker'),
        ajaxData = {
          data   : '',
          nonce  : btn.data('nonce') || '',
          action : btn.data('ajax-action') || 'vtcore_ajax_framework',            
          object : btn.data('ajax-object'),
          value  : btn.data('ajax-value'),
          target : btn.data('ajax-target'),
          elval  : btn.val()
        };
    
        
    // Processing if element is a select element
    if (btn.is('select')) {
      
      // Break ajax if user set the selected options to not do ajax
      if (btn.find('option[value="' + btn.val() + '"]').data('ajax-stop') == true) {
        return false;
      }
      
      btn.addClass('disabled').attr('disabled', true);
    }
    
    // Disabling button to prevent double posting
    if (btn.is('button')) {
      btn.html(btn.data('ajax-loading-text')).addClass('disabled').attr('disabled', true);
      ajaxData.nonce = btn.data('nonce');
    }
    
    if (btn.is('input')) {
      btn.val(btn.data('ajax-loading-text')).addClass('disabled').attr('disabled', true);
      ajaxData.nonce = btn.closest('form').find('[name="_nonce"]').val();
    }
    
    if (btn.is('a')) {
      btn.html(btn.data('ajax-loading-text')).addClass('disabled').attr('disabled', true);
      ajaxData.nonce = btn.data('nonce');
    }
    
    if (btn.data('ajax-group')) {
      $('[data-ajax-group="' + btn.data('ajax-group') + '"]').addClass('disabled').attr('disabled', true);
    }
    
    btn.addClass('ajax-processing');
    
    
    // Retrieve data
    if (typeof target != 'undefined' && typeof ajaxMode != 'undefined') {
      switch (ajaxMode) {
        case 'data' :
          ajaxData.data = $.param(target.data(), true);
          break;
          
        case 'post' :
          ajaxData.data = $.param(target.serializeArray(), true);
          break;
          
        case 'both' :
          ajaxData.data = $.param($.extend(target.serialize(), target.data()), true);
          break;
          
        case 'trigger' :
          ajaxData.data = btn.data('ajax-trigger');
          break;
          
        case 'value' :
          ajaxData.data = target.val();
          break;
        
        case 'selfData' :
          ajaxData.data = $.param(btn.data(), true);
          break;
      }
    }

    // Queueing ajax request
    for (var i=0; i < queue.length; i++) {
      
      // @bugfix value never changes bug
      var data = $.extend({}, ajaxData);
      data.queue = queue[i];

      // @bugfix at front no ajax url defined
      if (typeof wpajax.ajaxurl != 'undefined') {
        window.ajaxurl = wpajax.ajaxurl;
      }

      // Invoke AJAX request
      ajaxManager.addReq({
        cache : false,
        type : 'POST',
        url : window.ajaxurl,
        data : data,
        marker : marker,
        dataFilter : function(response) {
          
          // Processing the json data
          // PHP must return the data as the VTCore_Ajax API requires.
          return $(this).VTCoreProcessAjaxResponse(response);
        },
        success : function(response, status) {
          
          // Assigning the processed content to the appropriate location
          // PHP must return the data as the VTCore_Ajax API requires.
          $(this).VTCoreProcessAjaxReturn(response, status);
        }
      });   
    };
    
    // Processing queued requests
    ajaxManager.run(function() {               
      // Enabling the button again
      if (btn.is('button')) {
        btn.html(text).removeClass('disabled').removeAttr('disabled');
      }
      
      if (btn.is('input')) {
        btn.val(text).removeClass('disabled').removeAttr('disabled');
      }
      
      if (btn.is('a')) {
        btn.html(text).removeClass('disabled').removeAttr('disabled');
      }
      
      if (btn.data('ajax-group')) {
        $('[data-ajax-group="' + btn.data('ajax-group') + '"]').removeClass('disabled').removeAttr('disabled');
      }
      
      if (btn.is('select')) {
        btn.removeClass('disabled').removeAttr('disabled');
      }
      
    });
	}


	/**
	 * Bind the button click event.
	 */
	$(document)

      .on('click.btn-ajax', '.btn-ajax', function(e) {
      
        $(this).VTCoreInvokeAjax(e);

      })

      .on('change.btn-ajax', '.btn-ajax-change', function(e) {

        $(this).VTCoreInvokeAjax(e);

      })

      .on('doajax', '.btn-ajax-content', function(e) {

        $(this).VTCoreInvokeAjax(e);

      });

})(jQuery);;




// Time Line
(function($) {
  var VTTimeLine = function($el) {
    this.$el = $el;
    this.$children = this.$el.find('[data-timeline="items"]');
    this.$parent = this.$el.closest('[data-timeline="wrapper"]');
    this.$icon = this.$el.find('[data-timeline="icon"]');
    this.$bar = this.$parent.find('[data-timeline="bar"]');
    this.destroy();
    this.init();
    return this;
  }
  VTTimeLine.prototype = {
    init: function() {
      this
        .calculate()
        .adjustHeight()
        .adjustPosition()
        .adjustParent()
        .adjustLine()
        .buildScrollbar();

      return this;

    },
    adjustLine: function() {

      // Need better solution, use offset?
      this.offset = parseInt(this.$el.css('marginTop').replace('px', '')) + parseInt(this.$el.css('paddingTop').replace('px', ''));

      this.$icon.css({
        top: this.maxHeightBottom + 'px'
      });

      this.$bar.css({
        top: this.maxHeightBottom + this.offset + 'px'
      });
      return this;
    },
    adjustParent: function() {
      this.$el.css({
        height: this.totalHeight + 'px',
        width: this.totalWidth + 'px'
      });
      return this;
    },
    adjustHeight: function() {
      this.$children.css({
        height: this.totalHeight + 'px'
      });
      return this;
    },
    adjustPosition: function() {
      var that = this;
      this.$children.each(function() {
        switch ($(this).data('direction')) {
          case 'top' :
            $(this).css({
              paddingTop: that.maxHeightBottom + 'px'
            });

            break;
          case 'bottom' :
            $(this).css({
              paddingBottom: that.maxHeightTop + 'px'
            });

            // Check for gaps and push the child down
            if ($(this).children().innerHeight() < that.maxHeightBottom) {
              $(this).children().css({
                marginTop: that.maxHeightBottom - $(this).children().innerHeight() + 'px'
              });
            }
            break;
          case 'center' :
            $(this).css({
              paddingTop: that.maxHeightBottom + 'px'
            });
            $(this).children().css({
              marginTop: '-' + $(this).children().innerHeight() / 2 + 'px'
            })
            break;
        }
      });
      return this;
    },
    calculate: function() {

      // Reset
      this.maxHeightTop = 0;
      this.maxHeightBottom = 0;
      this.maxHeightCenter = 0;
      this.totalWidth = 0;

      var that = this;

      this.$children.each(function() {

        that.direction = $(this).data('direction');

        $(this).children().each(function() {
          that.innerHeight = $(this).innerHeight();
          switch (that.direction) {
            case 'top' :
              if (that.maxHeightTop < that.innerHeight) {
                that.maxHeightTop = that.innerHeight;
              }
              break;
            case 'bottom' :
              if (that.maxHeightBottom < that.innerHeight) {
                that.maxHeightBottom = that.innerHeight;
              }
              break;
            case 'center' :
              if (that.maxHeightCenter < that.innerHeight) {
                that.maxHeightCenter = that.innerHeight;
              }
              break;
          }
        });

        that.totalWidth += $(this).outerWidth(true);
      });

      this.totalHeight = this.maxHeightTop + this.maxHeightBottom;
      if (this.maxHeightCenter > this.totalHeight) {
        this.totalHeight = this.maxHeightCenter;
      }

      return this;
    },
    buildScrollbar: function() {
      this.$parent.customScrollbar({
        skin: 'timeline-skin',
        vScroll: false,
        updateOnWindowResize: true,
        fixedThumbHeight: 24,
        fixedThumbWidth: 48
      });

      this.$parent.find('.viewport').height(this.totalHeight);

      return this;
    },
    destroy: function() {
      this.$el.removeAttr('style');
      this.$children.removeAttr('style');
      this.$parent.customScrollbar('remove', true);

      return this;
    },
    refresh: function() {
      this.destroy();
      this.init();
    }
  }

  
  /**
   * Build the time line element
   */
  $.fn.VTCoreHorizontalTimeline = function() {
    return this.each(function() {
      var TimeLine = new VTTimeLine($(this).find('[data-timeline="element"]'));
      TimeLine = null;
      delete TimeLine;
    });
  }

  
  // VC needs load event for this to work properly!.
  $(window)
    .on('load', function() {
      $('[data-timeline="wrapper"]').filter('[data-layout="horizontal"]').VTCoreHorizontalTimeline();
    })
    .on('resize', function() {
      $('[data-timeline="wrapper"]').filter('[data-layout="horizontal"]').VTCoreHorizontalTimeline();
    })
 
})(window.jQuery);;




/*
 * Additional skins for dial knobs
 */
jQuery(document).ready(function($) {

  "use strict";

  // Double line skins style for knob element
  if ($('.dial-double').length != 0) {
    $('.dial-double').knob({
      'draw' : function(v) {

        this.innerRadius = this.radius - this.lineWidth - 3;
        this.g.beginPath();
        this.g.lineCap = this.lineCap;
        this.g.lineWidth = this.lineWidth;
        this.g.strokeStyle = this.o.inputColor;
        this.g.arc(this.xy, this.xy, this.innerRadius, this.startAngle + 0.00001, 2 * Math.PI, false);
        this.g.stroke();
      }
    });
  }
});




/*  jQuery Knob  */
/*
 * Downward compatible, touchable dial
 *
 * Version: 1.2.8
 * Requires: jQuery v1.7+
 *
 * Copyright (c) 2012 Anthony Terrien
 * Under MIT License (http://www.opensource.org/licenses/mit-license.php)
 *
 * Thanks to vor, eskimoblood, spiffistan, FabrizioC
 */

(function(factory) {
	"use strict";
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else {
        // Browser globals
        factory(jQuery);
    }
}
(function($) {

    /*
     * Kontrol library
     */

    "use strict";

    /**
     * Definition of globals and core
     */
    var k = {}, // kontrol
        max = Math.max,
        min = Math.min;

    k.c = {};
    k.c.d = $(document);
    k.c.t = function(e) {
        return e.originalEvent.touches.length - 1;
    };

    /**
     * Kontrol Object
     *
     * Definition of an abstract UI control
     *
     * Each concrete component must call this one.
     * <code>
     * k.o.call(this);
     * </code>
     */
    k.o = function() {
        var s = this;

        this.o = null; // array of options
        this.$ = null; // jQuery wrapped element
        this.i = null; // mixed HTMLInputElement or array of HTMLInputElement
        this.g = null; // deprecated 2D graphics context for 'pre-rendering'
        this.v = null; // value; mixed array or integer
        this.cv = null; // change value; not commited value
        this.x = 0; // canvas x position
        this.y = 0; // canvas y position
        this.w = 0; // canvas width
        this.h = 0; // canvas height
        this.$c = null; // jQuery canvas element
        this.c = null; // rendered canvas context
        this.t = 0; // touches index
        this.isInit = false;
        this.fgColor = null; // main color
        this.pColor = null; // previous color
        this.dH = null; // draw hook
        this.cH = null; // change hook
        this.eH = null; // cancel hook
        this.rH = null; // release hook
        this.scale = 1; // scale factor
        this.relative = false;
        this.relativeWidth = false;
        this.relativeHeight = false;
        this.$div = null; // component div

        this.run = function() {
            var cf = function(e, conf) {
                var k;
                for (k in conf) {
                    s.o[k] = conf[k];
                }
                s._carve().init();
                s._configure()
                    ._draw();
            };

            if (this.$.data('kontroled')) return;
            this.$.data('kontroled', true);

            this.extend();
            this.o = $.extend({
                // Config
                min: this.$.data('min') !== undefined ? this.$.data('min') : 0,
                max: this.$.data('max') !== undefined ? this.$.data('max') : 100,
                stopper: true,
                readOnly: this.$.data('readonly') || (this.$.attr('readonly') === 'readonly'),

                // UI
                cursor: (this.$.data('cursor') === true && 30) ||
                    this.$.data('cursor') || 0,
                thickness: (
                    this.$.data('thickness') &&
                    Math.max(Math.min(this.$.data('thickness'), 1), 0.01)
                ) || 0.35,
                lineCap: this.$.data('linecap') || 'butt',
                width: this.$.data('width') || 200,
                height: this.$.data('height') || 200,
                displayInput: this.$.data('displayinput') || null,
                displayPrevious: this.$.data('displayprevious'),
                displayText: this.$.data('displaytext') || false,
                fgColor: this.$.data('fgcolor') || '#87CEEB',
                inputColor: this.$.data('inputcolor'),
                font: this.$.data('font') || 'Arial',
                fontWeight: this.$.data('fontweight') || 'bold',
                fontSize: this.$.data('fontsize') || 1,
                inline: false,
                step: this.$.data('step') || 1,
                rotation: this.$.data('rotation'),

                // Hooks
                draw: null, // function () {}
                change: null, // function (value) {}
                cancel: null, // function () {}
                release: null, // function (value) {}

                // Output formatting, allows to add unit: %, ms ...
                format: function(v) {
                    return v;
                },
                parse: function(v) {
                    return parseFloat(v);
                }
            }, this.o);

            // finalize options
            this.o.flip = this.o.rotation === 'anticlockwise' || this.o.rotation === 'acw';
            if (!this.o.inputColor) {
                this.o.inputColor = this.o.fgColor;
            }

            // routing value
            if (this.$.is('fieldset')) {

                // fieldset = array of integer
                this.v = {};
                this.i = this.$.find('input');
                this.i.each(function(k) {
                    var $this = $(this);
                    s.i[k] = $this;
                    s.v[k] = s.o.parse($this.val());

                    $this.bind(
                        'change blur',
                        function() {
                            var val = {};
                            val[k] = $this.val();
                            s.val(val);
                        }
                    );
                });
                this.$.find('legend').remove();

            } else {

                // input = integer
                this.i = this.$;
                this.v = this.o.parse(this.$.val());
                (this.v === '') && (this.v = this.o.min);

                this.$.bind(
                    'change blur',
                    function() {
                        s.val(s._validate(s.o.parse(s.$.val())));
                    }
                );
            }

            (!this.o.displayInput) && this.$.hide();

            // adds needed DOM elements (canvas, div)
            this.$c = $(document.createElement('canvas')).attr({
                width: this.o.width,
                height: this.o.height
            });

            // wraps all elements in a div
            // add to DOM before Canvas init is triggered
            this.$div = $('<div class="knob-wrapper" style="' + (this.o.inline ? 'display:inline-block;' : '') + 'position:relative;' + 'width:' + this.o.width + 'px;height:' + this.o.height + 'px;' + '"></div>');

            this.$.wrap(this.$div).before(this.$c);
            this.$div = this.$.parent();

            if (typeof G_vmlCanvasManager !== 'undefined') {
                G_vmlCanvasManager.initElement(this.$c[0]);
            }

            this.c = this.$c[0].getContext ? this.$c[0].getContext('2d') : null;

            if (!this.c) {
                throw {
                    name: "CanvasNotSupportedException",
                    message: "Canvas not supported. Please use excanvas on IE8.0.",
                    toString: function() {
                        return this.name + ": " + this.message
                    }
                }
            }

            // hdpi support
            this.scale = (window.devicePixelRatio || 1) /
                (
                    this.c.webkitBackingStorePixelRatio ||
                    this.c.mozBackingStorePixelRatio ||
                    this.c.msBackingStorePixelRatio ||
                    this.c.oBackingStorePixelRatio ||
                    this.c.backingStorePixelRatio || 1
                );

            // detects relative width / height
            this.relativeWidth = ((this.o.width % 1 !== 0) &&
                this.o.width.indexOf('%'));
            this.relativeHeight = ((this.o.height % 1 !== 0) &&
                this.o.height.indexOf('%'));
            this.relative = (this.relativeWidth || this.relativeHeight);

            // computes size and carves the component
            this._carve();

            // prepares props for transaction
            if (this.v instanceof Object) {
                this.cv = {};
                this.copy(this.v, this.cv);
            } else {
                this.cv = this.v;
            }

            // binds configure event
            this.$
                .bind("configure", cf)
                .parent()
                .bind("configure", cf);

            // finalize init
            this._listen()
                ._configure()
                ._xy()
                .init();

            this.isInit = true;
            this.$.val(this.o.format(this.v));
            this._draw();

            return this;
        };

        this._carve = function() {
            if (this.relative) {
                var w = this.relativeWidth ?
                    this.$div.parent().width() *
                    parseInt(this.o.width) / 100 :
                    this.$div.parent().width(),
                    h = this.relativeHeight ?
                    this.$div.parent().height() *
                    parseInt(this.o.height) / 100 :
                    this.$div.parent().height();

                // apply relative
                this.w = this.h = Math.min(w, h);
            } else {
                this.w = this.o.width;
                this.h = this.o.height;
            }

            // finalize div
            this.$div.css({
                'width': this.w + 'px',
                'height': this.h + 'px'
            });

            // finalize canvas with computed width
            this.$c.attr({
                width: this.w,
                height: this.h
            });

            // scaling
            if (this.scale !== 1) {
                this.$c[0].width = this.$c[0].width * this.scale;
                this.$c[0].height = this.$c[0].height * this.scale;
                this.$c.width(this.w);
                this.$c.height(this.h);
            }

            return this;
        }

        this._draw = function() {
            // canvas pre-rendering
            var d = true;
            s.g = s.c;
            s.clear();
            s.dH && (d = s.dH());
            (d !== false) && s.draw();
        };

        this._touch = function(e) {

            var touchMove = function(e) {

                var v = s.xy2val(
                    e.originalEvent.touches[s.t].pageX,
                    e.originalEvent.touches[s.t].pageY
                );

                if (v == s.cv) return;

                if (s.cH && (s.cH(v) === false)) return;

                s.change(s._validate(v));
                s._draw();
            };

            // get touches index
            this.t = k.c.t(e);

            // First touch
            touchMove(e);

            // Touch events listeners
            k.c.d
                .bind("touchmove.k", touchMove)
                .bind(
                    "touchend.k",
                    function() {
                        k.c.d.unbind('touchmove.k touchend.k');
                        s.val(s.cv);
                    }
                );

            return this;
        };

        this._mouse = function(e) {

            var mouseMove = function(e) {
                var v = s.xy2val(e.pageX, e.pageY);

                if (v == s.cv) return;

                if (s.cH && (s.cH(v) === false)) return;

                s.change(s._validate(v));
                s._draw();
            };

            // First click
            mouseMove(e);

            // Mouse events listeners
            k.c.d
                .bind("mousemove.k", mouseMove)
                .bind(
                    // Escape key cancel current change
                    "keyup.k",
                    function(e) {
                        if (e.keyCode === 27) {
                            k.c.d.unbind("mouseup.k mousemove.k keyup.k");

                            if (
                                s.eH && (s.eH() === false)
                            ) return;

                            s.cancel();
                        }
                    }
                )
                .bind(
                    "mouseup.k",
                    function(e) {
                        k.c.d.unbind('mousemove.k mouseup.k keyup.k');
                        s.val(s.cv);
                    }
                );

            return this;
        };

        this._xy = function() {
            var o = this.$c.offset();
            this.x = o.left;
            this.y = o.top;
            return this;
        };

        this._listen = function() {

            if (!this.o.readOnly) {
                this.$c
                    .bind(
                        "mousedown",
                        function(e) {
                            e.preventDefault();
                            s._xy()._mouse(e);
                        }
                    )
                    .bind(
                        "touchstart",
                        function(e) {
                            e.preventDefault();
                            s._xy()._touch(e);
                        }
                    );

                this.listen();
            } else {
                this.$.attr('readonly', 'readonly');
            }

            if (this.relative) {
                $(window).resize(function() {
                    s._carve()
                        .init();
                    s._draw();
                });
            }

            return this;
        };

        this._configure = function() {

            // Hooks
            if (this.o.draw) this.dH = this.o.draw;
            if (this.o.change) this.cH = this.o.change;
            if (this.o.cancel) this.eH = this.o.cancel;
            if (this.o.release) this.rH = this.o.release;

            if (this.o.displayPrevious) {
                this.pColor = this.h2rgba(this.o.fgColor, "0.4");
                this.fgColor = this.h2rgba(this.o.fgColor, "0.6");
            } else {
                this.fgColor = this.o.fgColor;
            }

            return this;
        };

        this._clear = function() {
            this.$c[0].width = this.$c[0].width;
        };

        this._validate = function(v) {
            return (~~(((v < 0) ? -0.5 : 0.5) + (v / this.o.step))) * this.o.step;
        };

        // Abstract methods
        this.listen = function() {}; // on start, one time
        this.extend = function() {}; // each time configure triggered
        this.init = function() {}; // each time configure triggered
        this.change = function(v) {}; // on change
        this.val = function(v) {}; // on release
        this.xy2val = function(x, y) {}; //
        this.draw = function() {}; // on change / on release
        this.clear = function() {
            this._clear();
        };

        // Utils
        this.h2rgba = function(h, a) {
            var rgb;
            h = h.substring(1, 7)
            rgb = [parseInt(h.substring(0, 2), 16), parseInt(h.substring(2, 4), 16), parseInt(h.substring(4, 6), 16)];
            return "rgba(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + "," + a + ")";
        };

        this.copy = function(f, t) {
            for (var i in f) {
                t[i] = f[i];
            }
        };
    };

    /**
     * k.Dial
     */
    k.Dial = function() {
        k.o.call(this);

        this.startAngle = null;
        this.xy = null;
        this.radius = null;
        this.lineWidth = null;
        this.cursorExt = null;
        this.w2 = null;
        this.PI2 = 2 * Math.PI;

        this.extend = function() {
            this.o = $.extend({
                bgColor: this.$.data('bgcolor') || '#EEEEEE',
                angleOffset: this.$.data('angleoffset') || 0,
                angleArc: this.$.data('anglearc') || 360,
                inline: true
            }, this.o);
        };

        this.val = function(v, triggerRelease) {
            if (null != v) {

                // reverse format
                v = this.o.parse(v);

                if (
                    triggerRelease !== false && (v != this.v) && this.rH &&
                    (this.rH(v) === false)
                ) return;

                this.cv = this.o.stopper ? max(min(v, this.o.max), this.o.min) : v;
                this.v = this.cv;
                this.$.val(this.o.format(this.v));
                this._draw();
            } else {
                return this.v;
            }
        };

        this.xy2val = function(x, y) {
            var a, ret;

            a = Math.atan2(
                x - (this.x + this.w2), -(y - this.y - this.w2)
            ) - this.angleOffset;

            if (this.o.flip) {
                a = this.angleArc - a - this.PI2;
            }

            if (this.angleArc != this.PI2 && (a < 0) && (a > -0.5)) {
                // if isset angleArc option, set to min if .5 under min
                a = 0;
            } else if (a < 0) {
                a += this.PI2;
            }

            ret = ~~(0.5 + (a * (this.o.max - this.o.min) / this.angleArc)) + this.o.min;

            this.o.stopper && (ret = max(min(ret, this.o.max), this.o.min));

            return ret;
        };

        this.listen = function() {
            // bind MouseWheel
            var s = this,
                mwTimerStop, mwTimerRelease,
                mw = function(e) {
                    e.preventDefault();

                    var ori = e.originalEvent,
                        deltaX = ori.detail || ori.wheelDeltaX,
                        deltaY = ori.detail || ori.wheelDeltaY,
                        v = s._validate(s.o.parse(s.$.val())) + (deltaX > 0 || deltaY > 0 ? s.o.step : deltaX < 0 || deltaY < 0 ? -s.o.step : 0);

                    v = max(min(v, s.o.max), s.o.min);

                    s.val(v, false);

                    if (s.rH) {
                        // Handle mousewheel stop
                        clearTimeout(mwTimerStop);
                        mwTimerStop = setTimeout(function() {
                            s.rH(v);
                            mwTimerStop = null;
                        }, 100);

                        // Handle mousewheel releases
                        if (!mwTimerRelease) {
                            mwTimerRelease = setTimeout(function() {
                                if (mwTimerStop) s.rH(v);
                                mwTimerRelease = null;
                            }, 200);
                        }
                    }
                },
                kval, to, m = 1,
                kv = {
                    37: -s.o.step,
                    38: s.o.step,
                    39: s.o.step,
                    40: -s.o.step
                };

            this.$
                .bind(
                    "keydown",
                    function(e) {
                        var kc = e.keyCode;

                        // numpad support
                        if (kc >= 96 && kc <= 105) {
                            kc = e.keyCode = kc - 48;
                        }

                        kval = parseInt(String.fromCharCode(kc));

                        if (isNaN(kval)) {

                            (kc !== 13) // enter
                            && (kc !== 8) // bs
                            && (kc !== 9) // tab
                            && (kc !== 189) // -
                            && (kc !== 190 || s.$.val().match(/\./)) // . only allowed once
                            && e.preventDefault();

                            // arrows
                            if ($.inArray(kc, [37, 38, 39, 40]) > -1) {
                                e.preventDefault();

                                var v = s.o.parse(s.$.val()) + kv[kc] * m;
                                s.o.stopper && (v = max(min(v, s.o.max), s.o.min));

                                s.change(v);
                                s._draw();

                                // long time keydown speed-up
                                to = window.setTimeout(
                                    function() {
                                        m *= 2;
                                    }, 30
                                );
                            }
                        }
                    }
                )
                .bind(
                    "keyup",
                    function(e) {
                        if (isNaN(kval)) {
                            if (to) {
                                window.clearTimeout(to);
                                to = null;
                                m = 1;
                                s.val(s.$.val());
                            }
                        } else {
                            // kval postcond
                            (s.$.val() > s.o.max && s.$.val(s.o.max)) || (s.$.val() < s.o.min && s.$.val(s.o.min));
                        }

                    }
                );

            this.$c.bind("mousewheel DOMMouseScroll", mw);
            this.$.bind("mousewheel DOMMouseScroll", mw)
        };

        this.init = function() {

            if (
                this.v < this.o.min || this.v > this.o.max
            ) this.v = this.o.min;

            this.$.val(this.v);
            this.w2 = this.w / 2;
            this.cursorExt = this.o.cursor / 100;
            this.xy = this.w2 * this.scale;
            this.lineWidth = this.xy * this.o.thickness;
            this.lineCap = this.o.lineCap;
            this.radius = this.xy - this.lineWidth / 2;

            this.o.angleOffset && (this.o.angleOffset = isNaN(this.o.angleOffset) ? 0 : this.o.angleOffset);

            this.o.angleArc && (this.o.angleArc = isNaN(this.o.angleArc) ? this.PI2 : this.o.angleArc);

            // deg to rad
            this.angleOffset = this.o.angleOffset * Math.PI / 180;
            this.angleArc = this.o.angleArc * Math.PI / 180;

            // compute start and end angles
            this.startAngle = 1.5 * Math.PI + this.angleOffset;
            this.endAngle = 1.5 * Math.PI + this.angleOffset + this.angleArc;

            var s = max(
                String(Math.abs(this.o.max)).length, String(Math.abs(this.o.min)).length, 2
            ) + 2;

            this.o.displayInput && !this.o.displayText && this.i.css({
                'width': '100%',
                'height': '100%',
                'position': 'absolute',
                'vertical-align': 'middle',
                'top': '0px',
                'left': '0px',
                'right': '0px',
                'bottom': '0px',
                'border': 0,
                'background': 'none',
                'font': this.o.fontWeight + ' ' + ((this.w / s) >> 0) * this.o.fontSize + 'px ' + this.o.font,
                'text-align': 'center',
                'color': this.o.inputColor || this.o.fgColor,
                'padding': '0px',
                '-webkit-appearance': 'none'
            }) || this.i.css({
                'width': '0px',
                'visibility': 'hidden',
                'display': 'none'
            });

            if (this.o.displayText && !this.itext)
                this.itext = $('<div class="display-text">' + this.o.displayText + '</div>');

            this.itext && this.$div.append(this.itext) && this.itext.css({
                'width': '100%',
                'position': 'absolute',
                'display': 'table-cell',
                'vertical-align': 'middle',
                'top': '0px',
                'left': '0px',
                'right': '0px',
                'bottom': '0px',
                'border': 0,
                'background': 'none',
                'font': this.o.fontWeight + ' ' + ((this.w / s) >> 0) * this.o.fontSize + 'px ' + this.o.font,
                'text-align': 'center',
                'color': this.o.inputColor || this.o.fgColor,
                'padding': '0px',
                'line-height': this.h + 'px'
            });
        };

        this.change = function(v) {
            this.cv = v;
            this.$.val(this.o.format(v));
        };

        this.angle = function(v) {
            return (v - this.o.min) * this.angleArc / (this.o.max - this.o.min);
        };

        this.arc = function(v) {
            var sa, ea;
            v = this.angle(v);
            if (this.o.flip) {
                sa = this.endAngle + 0.00001;
                ea = sa - v - 0.00001;
            } else {
                sa = this.startAngle - 0.00001;
                ea = sa + v + 0.00001;
            }
            this.o.cursor && (sa = ea - this.cursorExt) && (ea = ea + this.cursorExt);
            return {
                s: sa,
                e: ea,
                d: this.o.flip && !this.o.cursor
            };
        };

        this.draw = function() {

            var c = this.g, // context
                a = this.arc(this.cv) // Arc
                ,
                pa // Previous arc
                , r = 1;

            this.radius = Math.abs(this.radius);

            c.lineWidth = this.lineWidth;
            c.lineCap = this.lineCap;

            c.beginPath();
            c.strokeStyle = this.o.bgColor;
            c.arc(this.xy, this.xy, this.radius, this.endAngle - 0.00001, this.startAngle + 0.00001, true);
            c.stroke();

            if (this.o.displayPrevious) {
                pa = this.arc(this.v);
                c.beginPath();
                c.strokeStyle = this.pColor;
                c.arc(this.xy, this.xy, this.radius, pa.s, pa.e, pa.d);
                c.stroke();
                r = (this.cv == this.v);
            }

            c.beginPath();
            c.strokeStyle = r ? this.o.fgColor : this.fgColor;
            c.arc(this.xy, this.xy, this.radius, a.s, a.e, a.d);
            c.stroke();
        };

        this.cancel = function() {
            this.val(this.v);
        };
    };

    $.fn.dial = $.fn.knob = function(o) {
        return this.each(
            function() {
                var d = new k.Dial();
                d.o = o;
                d.$ = $(this);
                d.run();
            }
        ).parent();
    };

    $.fn.dialInit = function() {
        return this.each(function() {

            var self = $(this),
                skin = function(v) {};

            /**
             * Skins collections
             * Please add more skins in this area
             */
            // Double line skins style for knob element
            if (self.hasClass('dial-double-line')) {
                skin = function(v) {
                    this.innerRadius = Math.abs(this.radius - this.lineWidth - 3);
                    this.g.beginPath();
                    this.g.lineCap = this.lineCap;
                    this.g.lineWidth = this.lineWidth;
                    this.g.strokeStyle = this.o.inputColor;
                    this.g.arc(this.xy, this.xy, this.innerRadius, this.startAngle + 0.00001, 2 * Math.PI, false);
                    this.g.stroke();
                };
            }

            // Inner text get circle wrapping
            if (self.hasClass('dial-fill-circle')) {
                skin = function(v) {
                    this.g.beginPath();
                    this.g.fillStyle = this.o.bgColor;
                    this.g.arc(this.xy, this.xy, Math.abs(this.radius * 0.7), 0, 2 * Math.PI, false);
                    this.g.fill();
                }
            }

            self.addClass('processed').knob({
                'draw': skin,
                'format': function(v) {
                    if (self.data('prefix')) {
                        v = self.data('prefix') + v;
                    }

                    if (self.data('suffix')) {
                        v = v + self.data('suffix');
                    }

                    return v;
                }
            });

            var classes = self.attr('class').replace('jqknob', '').replace('processed', '');
            self.removeClass(classes).parent().addClass(classes);

        });
    }

    $(window)
        .on('load', function() {
            $('.jqknob:not(.processed)').dialInit();
        });

    $(document)
        .on('ajaxComplete', function(event, xhr, settings) {
            $('.jqknob:not(.processed)').dialInit();
        });

}));;




/* 
 * @preserve jQuery flipcountdown plugin v3.0.4
 * @homepage http://xdsoft.net/jqplugins/flipcountdown/
 * (c) 2013, Chupurnov Valeriy.
 */
(function($){
"use strict";
jQuery.fn.flipCountDown = jQuery.fn.flipcountdown = function( _options ){
	var default_options = {
			showHour	:true,
			showMinute	:true,
			showSecond	:true,
			am			:false,

			tzoneOffset	:0,
			speedFlip	:60,
			period		:1000,
			tick		:function(){
							return new Date();
						},
			autoUpdate	:true,
			size		:'md'
		},
		
		sizes = {
			lg:77,
			md:52,
			sm:35,
			xs:24
		},
		
		createFlipCountDown = function( $box ){
			var $flipcountdown 	= $('<div class="xdsoft_flipcountdown"></div>'),
				$clearex 		= $('<div class="xdsoft_clearex"></div>'),	 
				
				options = $.extend({},default_options),
				
				timer = 0,
				
				_animateRange = function( box,a,b ){
					_animateOne( box,a,(a>b&&!(a==9&&b==0))?-1:1,!(a==9&&b==0)?Math.abs(a-b):1 );
				},
				
				_animateOne = function( box,a,arrow,range ){
					if( range<1 )
						return;
	
					_setMargin(box,-(a*6*sizes[options.size]+1),1,arrow,function(){
						_animateOne(box,a+arrow,arrow,range-1);
					},range);
				},
				
				_setMargin = function( box, marginTop, rec, arrow,callback,range){
					if( marginTop<=-sizes[options.size]*60 )
						marginTop = -1;
					box.css('background-position','0px '+marginTop+'px' );
					if( rec<=6 ){
						setTimeout(function(){
							_setMargin(box, marginTop-arrow*sizes[options.size], ++rec, arrow, callback,range);	
						},parseInt(options.speedFlip/range));
					}else
						callback();
				},
				
				blocks = [],
				
				_typeCompare	= 	function ( a,b ){
					return 	a&&b&&(
								(a==b)||
								(/^[0-9]+$/.test(a+''+b))||
								(/^[:.\s]+$/.test(a+''+b))
							);
				},
				
				_generate = function( chars ){
					if( !(chars instanceof Array) || !chars.length )
						return false;
					for( var i = 0, n = chars.length;i<n;i++ ){
						if( !blocks[i] ){
							blocks[i] = $('<div class="xdsoft_digit"></div>');
							$clearex.before(blocks[i]);
						}
						if( blocks[i].data('value')!=chars[i] ){
							if( !_typeCompare(blocks[i].data('value'),chars[i]) ){
								blocks[i]
									.removeClass('xdsoft_separator')
									.removeClass('xdsoft_dot');
								switch( chars[i] ){
									case ':':blocks[i].addClass('xdsoft_separator');break;
									case '.':blocks[i].addClass('xdsoft_dot');break; 
									case ' ':blocks[i].addClass('xdsoft_space');break; 
								}
							}
							if( !isNaN(chars[i]) ){
								var old = parseInt(blocks[i].data('value')), 
									ii = parseInt(blocks[i].data('i')),
									crnt = parseInt(chars[i]);
								if( isNaN(old)||i!=ii ){
									old = (crnt-1)<0?9:crnt-1;
								}
								_animateRange(blocks[i],old,crnt);
							}
							blocks[i].data('value',chars[i]);
							blocks[i].data('i',i);
						}
					}
					if( blocks.length>chars.length ){
						for(;i<blocks.length;i++ ){
							blocks[i][0].parentNode.removeChild(blocks[i][0]);
							delete blocks[i];
						}
						blocks.splice(chars.length);
					}
					
				},
				
				counter = 0,
				
				_calcMoment = function(){
					var value = '1',chars = [];
					if(options.tick)
						value = (options.tick instanceof Function)?options.tick.call($box,counter):options.tick;
					
					if( typeof value!=='undefined' ){
						switch( value.constructor ){
							case Date:
								var h = (value.getHours()+options.tzoneOffset)%(options.am?12:24);
		
								if( options.showHour ){
									chars.push(parseInt(h/10));
									chars.push(h%10);
								}
										
								if( options.showHour && (options.showMinute || options.showSecond) )
									chars.push(':');
								
								if( options.showMinute ){
									chars.push(parseInt(value.getMinutes()/10));
									chars.push(value.getMinutes() % 10);
								}
								
								if( options.showMinute && options.showSecond )
									chars.push(':');
								
								if( options.showSecond ){
									chars.push(parseInt(value.getSeconds()/10));
									chars.push(value.getSeconds() % 10);
								}
							break;
							case String:
								chars = value.replace(/[^0-9\:\.\s]/g,'').split('');
							break;
							case Number:
								chars = value.toString().split('');
							break;
						}
						_generate(chars);
					}
				};
				
			$flipcountdown
				.append($clearex)
				.on('xdinit.xdsoft',function(){
					clearInterval(timer);
					if( options.autoUpdate )
						timer = setInterval( _calcMoment,options.period );
					_calcMoment();
				});
				
			$box.data('setOptions',function( _options ){
				options = $.extend({},options,_options);
				if( !sizes[options.size] )
					options.size = 'lg';
				$flipcountdown
					.addClass('xdsoft_size_'+options.size)
					.trigger('xdinit.xdsoft');
			});
			$box.append($flipcountdown);
		};	
	return this.each(function(){
		var $box = $(this);
		if( !$box.data('setOptions') ){
			$box.addClass('xdsoft')
			createFlipCountDown($box);
		}
		$box.data('setOptions')&&
			$.isFunction($box.data('setOptions'))&&
				$box.data('setOptions')(_options);
	});
}

// Autoload element
$('.jqflipcountdown').each( function() {
	"use strict";
	var data = $(this).data('settings');

	if (typeof data != 'undefined' && typeof data.startDate != 'undefined' && data.startDate != '') {
	  var NY = Math.round((new Date(data.startDate)).getTime()/1000);
		data.tick = function(){

			var nol = function(h){
				return h>9?h:'0'+h;
			};
			
			var	range  	= 	NY-Math.round((new Date()).getTime()/1000),
				secday	= 	86400, sechour = 3600,
				days	= 	parseInt(range/secday),
				hours	= 	parseInt((range%secday)/sechour),
				min	= 	parseInt(((range%secday)%sechour)/60),
				sec	= 	((range%secday)%sechour)%60;
			
			
			var output = '';
			
	    if (typeof data.showDays == 'undefined' || data.showDays == true) {
	      output += nol(days);
	    }
	    
	    if (typeof data.showHour == 'undefined' || data.showHour == true) {
	      output += ' ' + nol(hours);
	    }
	    
      if (typeof data.showMinute == 'undefined' || data.showMinute == true) {
        output += ' ' + nol(min);
      }	    
      
      if (typeof data.showSecond == 'undefined' || data.showSecond == true) {
        output += ' ' + nol(sec);
      }

      return output;
		};
	}

	$(this).flipcountdown(data);
	
});

})(jQuery);;




/*
 * Modified version, don't update with original!
 * 
 * Allowing public function to destroy the flipster and revert back to original html
 */
(function($) {
$.fn.flipster = function(options) {
	var isMethodCall = typeof options === 'string' ? true : false;

	if (isMethodCall) {
		var method = options;
		var args = Array.prototype.slice.call(arguments, 1);
	} else {
		var defaults = {
			itemContainer:			'ul', // Container for the flippin' items.
			itemSelector:				'li', // Selector for children of itemContainer to flip
			style:							'coverflow', // Switch between 'coverflow' or 'carousel' display styles
			start:							'center', // Starting item. Set to 0 to start at the first, 'center' to start in the middle or the index of the item you want to start with.
			
			enableKeyboard:			true, // Enable left/right arrow navigation
			enableMousewheel:		true, // Enable scrollwheel navigation (up = left, down = right)
			enableTouch:				true, // Enable swipe navigation for touch devices
			
			enableNav:					false, // If true, flipster will insert an unordered list of the slides
			enableNavButtons:		false, // If true, flipster will insert Previous / Next buttons
			
			onItemSwitch:				function(){}, // Callback function when items are switches
			disableRotation: false
		};
		var settings = $.extend({}, defaults, options);
		var win = $(window);
	}
	
	return this.each(function(){
		
		var _flipster = $(this);
		var methods;

		if (isMethodCall) {
			methods = _flipster.data('methods');
			return methods[method].apply(this, args);
		}

		var	_flipItemsOuter;
		var	_flipItems;
		var	_flipNav;
		var	_flipNavItems;
		var	_current = 0;
		
		var _startTouchX = 0;
		var _actionThrottle = 0;
		var _throttleTimeout;
		var compatibility;

		// public methods
		methods = {
			jump: jump,
			destroy: destroy
		};
		_flipster.data('methods', methods);

		function removeThrottle() {
			_actionThrottle = 0;
		}

    function resize() {
        _flipItemsOuter.width('auto').height('auto');
        _flipItemsOuter.height(calculateBiggestFlipItemHeight());
        _flipster.css("height","auto");
        if ( settings.style === 'carousel' ) { _flipItemsOuter.width(_flipItems.width()); }
    }

    function calculateBiggestFlipItemHeight() {
        var biggestHeight = 0;
        _flipItems.each(function() {
            if ($(this).height() > biggestHeight) biggestHeight = $(this).height();
        });
        return biggestHeight;
    }

		function buildNav() {
			if ( settings.enableNav && _flipItems.length > 1 ) {
				var navCategories = [],
					navItems = [],
					navList = [];
				
				_flipItems.each(function(){
					var category = $(this).data("flip-category"),
						itemId = $(this).attr("id"),
						itemTitle = $(this).attr("title");

					if ( typeof category !== 'undefined' ) {
						if ( $.inArray(category,navCategories) < 0 ) {
							navCategories.push(category);
							navList[category] = '<li class="flip-nav-category"><a href="#" class="flip-nav-category-link" data-flip-category="'+category+'">'+category+'</a>\n<ul class="flip-nav-items">\n';
						}
					}
					
					if ( $.inArray(itemId,navItems) < 0 && typeof itemTitle !== 'undefined') {
					  
					  navItems.push(itemId);
					  link = '<a href="#'+itemId+'" class="flip-nav-item-link">'+itemTitle+'</a></li>\n';
					  
						if ( typeof category !== 'undefined' ) {
							navList[category] = navList[category] + '<li class="flip-nav-item">' + link;
						} else {
							navList[itemId] = '<li class="flip-nav-item no-category">' + link;
						}
					}
				});
				
				navDisplay = '<ul class="flipster-nav">\n';
				for ( var catIndex in navCategories ) {
					navList[navCategories[catIndex]] = navList[navCategories[catIndex]] + "</ul>\n</li>\n";
				}
				for ( var navIndex in navList ) { navDisplay += navList[navIndex]; }
				navDisplay += '</ul>';
				
				_flipNav = $(navDisplay).prependTo(_flipster);
				_flipNavItems = _flipNav.find("a").on("click",function(e){
					var target;
					if ( $(this).hasClass("flip-nav-category-link") ) {
						target = _flipItems.filter("[data-flip-category='"+$(this).data("flip-category")+"']");
					} else {
						target = $(this.hash);
					}
					
					if ( target.length ) {
						jump(target);
						e.preventDefault();
					}
				});
			}
		}
		
		function updateNav() {
			if ( settings.enableNav && _flipItems.length > 1 ) {
				currentItem = $(_flipItems[_current]);
				_flipNav.find(".flip-nav-current").removeClass("flip-nav-current");
				_flipNavItems.filter("[href='#"+currentItem.attr("id")+"']").addClass("flip-nav-current");
				_flipNavItems.filter("[data-flip-category='"+currentItem.data("flip-category")+"']").parent().addClass("flip-nav-current");
			}
		}
		
		function buildNavButtons() {

			if ( settings.enableNavButtons && _flipItems.length > 1 ) {
				_flipster.find(".flipto-prev, .flipto-next").remove();
				_flipster.append("<a href='#' class='flipto-prev'>Previous</a> <a href='#' class='flipto-next'>Next</a>");
				
				_flipster.children('.flipto-prev').on("click", function(e) {
					jump("left");
					e.preventDefault();
				});
				
				_flipster.children('.flipto-next').on("click", function(e) {
					jump("right");
					e.preventDefault();
				});
			}
		}
		
		function center() {
			var currentItem = $(_flipItems[_current]).addClass("flip-current");
			
			_flipItems.removeClass("flip-prev flip-next flip-current flip-past flip-future no-transition");
		
			if ( settings.style === 'carousel' ) {
				
				_flipItems.addClass("flip-hidden");
			
				var nextItem = $(_flipItems[_current+1]),
					futureItem = $(_flipItems[_current+2]),
					prevItem = $(_flipItems[_current-1]),
					pastItem = $(_flipItems[_current-2]);
				
				if ( _current === 0 ) {
					prevItem = _flipItems.last();
					pastItem = prevItem.prev();
				}
				else if ( _current === 1 ) {
					pastItem = _flipItems.last();
				}
				else if ( _current === _flipItems.length-2 ) {
					futureItem = _flipItems.first();
				}
				else if ( _current === _flipItems.length-1 ) {
					nextItem = _flipItems.first();
					futureItem = $(_flipItems[1]);
				}
					
				futureItem.removeClass("flip-hidden").addClass("flip-future");
				pastItem.removeClass("flip-hidden").addClass("flip-past");
				nextItem.removeClass("flip-hidden").addClass("flip-next");
				prevItem.removeClass("flip-hidden").addClass("flip-prev");
					
			} else {
				var spacer = currentItem.outerWidth()/2;
				var totalLeft = 0;
				var totalWidth = _flipItemsOuter.width();
				var currentWidth = currentItem.outerWidth();
				var currentLeft = (_flipItems.index(currentItem)*currentWidth)/2 +spacer/2;
				
				_flipItems.removeClass("flip-hidden");
				
				for (i = 0; i < _flipItems.length; i++) {
					var thisItem = $(_flipItems[i]);
					var thisWidth = thisItem.outerWidth();
					
					if (i < _current) {
						thisItem.addClass("flip-past")
							.css({
								"z-index" : i,
								"left" : (i*thisWidth/2)+"px"
							});
					}
					else if ( i > _current ) {
						thisItem.addClass("flip-future")
							.css({
								"z-index" : _flipItems.length-i,
								"left" : (i*thisWidth/2)+spacer+"px"
							});
					}
				}
				
				currentItem.css({
					"z-index" : _flipItems.length+1,
					"left" : currentLeft +"px"
				});
				
				totalLeft = (currentLeft + (currentWidth/2)) - (totalWidth/2);
				var newLeftPos = -1*(totalLeft)+"px";
/* Untested Compatibility */

				if (compatibility) {
					_flipItemsOuter.animate({"left":newLeftPos}, 333);
				}
				else {
					_flipItemsOuter.css("left", newLeftPos);
				}
			}
				
			currentItem
				.addClass("flip-current")
				.removeClass("flip-prev flip-next flip-past flip-future flip-hidden");
			
			resize();
			updateNav();
			settings.onItemSwitch.call(this);
		}
		
		function jump(to) {
			if ( _flipItems.length > 1 ) {
				if ( to === "left" ) {
					if ( _current > 0 ) { _current--; }
					else { _current = _flipItems.length-1; }
				}
				else if ( to === "right" ) {
					if ( _current < _flipItems.length-1 ) { _current++; }
					else { _current = 0; }
				} else if ( typeof to === 'number' ) {
					_current = to;
				} else {
					// if object is sent, get its index
					_current = _flipItems.index(to);
				}
				center();
			}
		}
	
		function init() {
/* Untested Compatibility */
				
			// Basic setup
			_flipster.addClass("flipster flipster-active flipster-"+settings.style).css("visibility","hidden");
			if (settings.disableRotation)
			  _flipster.addClass('no-rotate');
			_flipItemsOuter = _flipster.find(settings.itemContainer).addClass("flip-items");
			_flipItems = _flipItemsOuter.find(settings.itemSelector).addClass("flip-item flip-hidden").wrapInner("<div class='flip-content' />");
			
			//Browsers that don't support CSS3 transforms get compatibility:
			var isIEmax8 = ('\v' === 'v'); //IE <= 8
			var checkIE = document.createElement("b");
			checkIE.innerHTML = "<!--[if IE 9]><i></i><![endif]-->"; //IE 9
			var isIE9 = checkIE.getElementsByTagName("i").length === 1;
			if (isIEmax8 || isIE9) {
				compatibility = true;
				_flipItemsOuter.addClass("compatibility");
			}
			
	
			// Insert navigation if enabled.
			buildNav();
			buildNavButtons();
			
			
			// Set the starting item
			if ( settings.start && _flipItems.length > 1 ) {
				// Find the middle item if start = center
				if ( settings.start === 'center' ) {
					if (!_flipItems.length % 2) {
						_current = _flipItems.length/2 + 1;
					}
					else {
						_current = Math.floor(_flipItems.length/2);
					}
				} else {
					_current = settings.start;
				}
			}
			
			
			// initialize containers
			resize();
			
			
			// Necessary to start flipster invisible and then fadeIn so height/width can be set accurately after page load
			_flipster.hide().css("visibility","visible").fadeIn(400,function(){ center(); });
			
			
			// Attach event bindings.
			win.resize(function(){ resize(); center(); });
			
			
			// Navigate directly to an item by clicking
			_flipItems.on("click", function(e) {
				if ( !$(this).hasClass("flip-current") ) { e.preventDefault(); }
				jump(_flipItems.index(this));
			});
			
			
			// Keyboard Navigation
			if ( settings.enableKeyboard && _flipItems.length > 1 ) {
				win.on("keydown.flipster", function(e) {
					_actionThrottle++;
					if (_actionThrottle % 7 !== 0 && _actionThrottle !== 1) return; //if holding the key down, ignore most events
					
					var code = e.which;
					if (code === 37 ) {
						e.preventDefault();
						jump('left');
					}
					else if (code === 39 ) {
						e.preventDefault();
						jump('right');
					}
				});
		
				win.on("keyup.flipster", function(e){
					_actionThrottle = 0; //reset action throttle on key lift to avoid throttling new interactions
				});
			}
			
			
			// Mousewheel Navigation
			if ( settings.enableMousewheel && _flipItems.length > 1 ) { // TODO: Fix scrollwheel on Firefox
				_flipster.on("mousewheel.flipster", function(e){
					_throttleTimeout = window.setTimeout(removeThrottle, 500); //throttling should expire if scrolling pauses for a moment.
					_actionThrottle++;
					if (_actionThrottle % 4 !==0 && _actionThrottle !== 1) return; //throttling like with held-down keys
					window.clearTimeout(_throttleTimeout);
					
					if ( e.originalEvent.wheelDelta /120 > 0 ) { jump("left"); }
					else { jump("right"); }
					
					e.preventDefault();
				});
			}
			
			
			// Touch Navigation
			if ( settings.enableTouch && _flipItems.length > 1 ) {
				_flipster.on("touchstart.flipster", function(e) {
					_startTouchX = e.originalEvent.targetTouches[0].screenX;
				});
		
				_flipster.on("touchmove.flipster", function(e) {
					e.preventDefault();
					var nowX = e.originalEvent.targetTouches[0].screenX;
					var touchDiff = nowX-_startTouchX;
					if (touchDiff > _flipItems[0].clientWidth/1.75){
						jump("left");
						_startTouchX = nowX;
					}else if (touchDiff < -1*(_flipItems[0].clientWidth/1.75)){
						jump("right");
						_startTouchX = nowX;
					}
				});
		
				_flipster.on("touchend.flipster", function(e) {
					_startTouchX = 0;
				});
			}
		}
		
		
		function destroy() {
     
      _flipItems.each(function() {
        $(this).find('.flip-content > *').unwrap();
      });
    
      win.off("keydown.flipster");
      win.off("keyup.flipster");
      _flipster
          .removeClass("flipster flipster-active flipster-"+settings.style+" no-rotate")
          .off("click.flipster mousewheel.flipster touchstart.flipster touchmove.flipster touchend.flipster")
          .find(".flipster-nav, .flipto-prev, .flipto-next").remove();
      _flipItemsOuter
          .removeAttr('style')
          .removeClass("flip-items compatibility");
      _flipItems
          .off('click')
          .removeAttr('style')
          .removeClass("flip-prev flip-next flip-current flip-past flip-hidden flip-future no-transition");
      
      _flipster.addClass('flipster');
		}
		
		// Initialize if flipster is not already active.
		if ( !_flipster.hasClass("flipster-active") ) { init(); }
	});
};

// Auto boot
$('.flipster').each(function() {
  "use strict";
  $(this).flipster($(this).data('settings'));
});
})( jQuery );;




/*
 * @name		Shuffle Letters
 * @author		Martin Angelov
 * @version 	1.0
 * @url			http://tutorialzine.com/2011/09/shuffle-letters-effect-jquery/
 * @license		MIT License
 */

(function($){
"use strict";	
	$.fn.shuffleLetters = function(prop){
		
		var options = $.extend({
			"step"		: 8,			// How many times should the letters be changed
			"fps"		: 25,			// Frames Per Second
			"text"		: "", 			// Use this text instead of the contents
			"callback"	: function(){}	// Run once the animation is complete
		},prop)
		
		return this.each(function(){
			
			var el = $(this),
				str = "";


			// Preventing parallel animations using a flag;

			if(el.data('animated')){
				return true;
			}
			
			el.data('animated',true);
			
			
			if(options.text) {
				str = options.text.split('');
			}
			else {
				str = el.html().split('');
			}
			
			// The types array holds the type for each character;
			// Letters holds the positions of non-space characters;
			
			var types = [],
				letters = [],
	      skip = false;

			// Looping through all the chars of the string

			for(var i=0;i<str.length;i++){
				
				var ch = str[i];
				
				if (ch == '<') {
				  skip = true;
				}
				
        if (ch == '>') {
          skip = false;
          continue;
        }

				if (skip == true) {
				  continue;
				}

				if(ch == " "){
					types[i] = "space";
					continue;
				}
				else if(/[a-z]/.test(ch)){
					types[i] = "lowerLetter";
				}
				else if(/[A-Z]/.test(ch)){
					types[i] = "upperLetter";
				}
				else {
					types[i] = "symbol";
				}
        				
				letters.push(i);
			}
			
			el.html("");			

			// Self executing named function expression:
			
			(function shuffle(start){
			
				// This code is run options.fps times per second
				// and updates the contents of the page element
					
				var i,
					len = letters.length, 
					strCopy = str.slice(0);	// Fresh copy of the string
					
				if(start>len){
					
					// The animation is complete. Updating the
					// flag and triggering the callback;
					
					el.data('animated',false);
					options.callback(el);
					return;
				}
				
				// All the work gets done here
				for(i=Math.max(start,0); i < len; i++){

					// The start argument and options.step limit
					// the characters we will be working on at once
					
					if( i < start+options.step){
						// Generate a random character at thsi position
						strCopy[letters[i]] = randomChar(types[letters[i]]);
					}
					else {
						strCopy[letters[i]] = "";
					}
				}
				
				el.html(strCopy.join(""));
				
				setTimeout(function(){
					
					shuffle(start+1);
					
				},1000/options.fps);
				
			})(-options.step);
			

		});
	};
	
	function randomChar(type){
		var pool = "";
		
		if (type == "lowerLetter"){
			pool = "abcdefghijklmnopqrstuvwxyz0123456789";
		}
		else if (type == "upperLetter"){
			pool = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
		}
		else if (type == "symbol"){
			pool = ",.?/\\(^)![]{}*&^%$#'\"";
		}
		
		var arr = pool.split('');
		return arr[Math.floor(Math.random()*arr.length)];
	}
	
	$('.jqshuffleletter').each(function() {
		$(this).shuffleLetters($(this).data());
	});
	
})(jQuery);;




/*
 _ _      _       _
 ___| (_) ___| | __  (_)___
 / __| | |/ __| |/ /  | / __|
 \__ \ | | (__|   < _ | \__ \
 |___/_|_|\___|_|\_(_)/ |___/
 |__/

 Version: 1.3.15
 Author: Ken Wheeler
 Website: http://kenwheeler.github.io
 Docs: http://kenwheeler.github.io/slick
 Repo: http://github.com/kenwheeler/slick
 Issues: http://github.com/kenwheeler/slick/issues

*/

/* global window, document, define, jQuery, setInterval, clearInterval */

(function (factory) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['jquery'], factory);
  }
  else {
    if (typeof exports !== 'undefined') {
      module.exports = factory(require('jquery'));
    }
    else {
      factory(jQuery);
    }
  }

}(function ($) {
  'use strict';
  var Slick = window.Slick || {};

  Slick = (function () {

    var instanceUid = 0;

    function Slick(element, settings) {

      var _ = this,
        responsiveSettings, breakpoint;

      _.defaults = {
        accessibility: true,
        adaptiveHeight: true,
        appendArrows: $(element),
        appendDots: $(element),
        arrows: true,
        asNavFor: null,
        prevArrow: '<button type="button" data-role="none" class="slick-prev">Previous</button>',
        nextArrow: '<button type="button" data-role="none" class="slick-next">Next</button>',
        autoplay: false,
        autoplaySpeed: 3000,
        centerMode: false,
        centerPadding: '50px',
        cssEase: 'ease',
        customPaging: function (slider, i) {
          return '<button type="button" class="btn btn-primary" data-role="none">' + (i + 1) + '</button>';
        },
        dots: false,
        dotsClass: 'slick-dots',
        draggable: true,
        easing: 'linear',
        fade: false,
        focusOnSelect: false,
        infinite: true,
        initialSlide: 0,
        lazyLoad: 'ondemand',
        onBeforeChange: null,
        onAfterChange: null,
        onInit: null,
        onReInit: null,
        onSetPosition: null,
        pauseOnHover: true,
        pauseOnDotsHover: false,
        respondTo: 'window',
        responsive: [
          {
            breakpoint: 480,
            settings: {
              slidesToShow: 1,
              slidesToScroll: 1
            }
          }
        ],
        rtl: false,
        slide: 'div',
        slidesToShow: 1,
        slidesToScroll: 1,
        speed: 500,
        swipe: true,
        swipeToSlide: false,
        touchMove: true,
        touchThreshold: 5,
        useCSS: true,
        variableWidth: true,
        vertical: false,
        waitForAnimate: true
      };

      _.initials = {
        animating: false,
        dragging: false,
        autoPlayTimer: null,
        currentDirection: 0,
        currentLeft: null,
        currentSlide: 0,
        direction: 1,
        $dots: null,
        listWidth: null,
        listHeight: null,
        loadIndex: 0,
        $nextArrow: null,
        $prevArrow: null,
        slideCount: null,
        slideWidth: null,
        $slideTrack: null,
        $slides: null,
        sliding: false,
        slideOffset: 0,
        swipeLeft: null,
        $list: null,
        touchObject: {},
        transformsEnabled: false
      };

      $.extend(_, _.initials);

      _.activeBreakpoint = null;
      _.animType = null;
      _.animProp = null;
      _.breakpoints = [];
      _.breakpointSettings = [];
      _.cssTransitions = false;
      _.paused = false;
      _.positionProp = null;
      _.respondTo = null;
      _.shouldClick = true;
      _.$slider = $(element);
      _.$slidesCache = null;
      _.transformType = null;
      _.transitionType = null;
      _.windowWidth = 0;
      _.windowTimer = null;

      _.options = $.extend({}, _.defaults, settings);

      _.currentSlide = _.options.initialSlide;

      _.originalSettings = _.options;
      responsiveSettings = _.options.responsive || null;

      if (responsiveSettings && responsiveSettings.length > -1) {
        _.respondTo = _.options.respondTo || "window";
        for (breakpoint in responsiveSettings) {
          if (responsiveSettings.hasOwnProperty(breakpoint)) {
            _.breakpoints.push(responsiveSettings[
              breakpoint].breakpoint);
            _.breakpointSettings[responsiveSettings[
              breakpoint].breakpoint] =
              responsiveSettings[breakpoint].settings;
          }
        }

        _.breakpoints.sort(function (a, b) {
          return b - a;
        });
      }

      _.autoPlay = $.proxy(_.autoPlay, _);
      _.autoPlayClear = $.proxy(_.autoPlayClear, _);
      _.changeSlide = $.proxy(_.changeSlide, _);
      _.clickHandler = $.proxy(_.clickHandler, _);
      _.selectHandler = $.proxy(_.selectHandler, _);
      _.setPosition = $.proxy(_.setPosition, _);
      _.swipeHandler = $.proxy(_.swipeHandler, _);
      _.dragHandler = $.proxy(_.dragHandler, _);
      _.keyHandler = $.proxy(_.keyHandler, _);
      _.autoPlayIterator = $.proxy(_.autoPlayIterator, _);

      _.instanceUid = instanceUid++;

      // A simple way to check for HTML strings
      // Strict HTML recognition (must start with <)
      // Extracted from jQuery v1.11 source
      _.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/;

      _.init();

      _.checkResponsive();

    }

    return Slick;

  }());

  Slick.prototype.addSlide = function (markup, index, addBefore) {

    var _ = this;

    if (typeof(index) === 'boolean') {
      addBefore = index;
      index = null;
    }
    else {
      if (index < 0 || (index >= _.slideCount)) {
        return false;
      }
    }

    _.unload();

    if (typeof(index) === 'number') {
      if (index === 0 && _.$slides.length === 0) {
        $(markup).appendTo(_.$slideTrack);
      }
      else {
        if (addBefore) {
          $(markup).insertBefore(_.$slides.eq(index));
        }
        else {
          $(markup).insertAfter(_.$slides.eq(index));
        }
      }
    }
    else {
      if (addBefore === true) {
        $(markup).prependTo(_.$slideTrack);
      }
      else {
        $(markup).appendTo(_.$slideTrack);
      }
    }

    _.$slides = _.$slideTrack.children(this.options.slide);

    _.$slideTrack.children(this.options.slide).detach();

    _.$slideTrack.append(_.$slides);

    _.$slides.each(function (index, element) {
      $(element).attr("index", index);
    });

    _.$slidesCache = _.$slides;

    _.reinit();

  };

  Slick.prototype.animateSlide = function (targetLeft, callback) {

    var animProps = {}, _ = this;

    if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
      var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
      _.$list.animate({height: targetHeight}, _.options.speed);
    }

    if (_.options.rtl === true && _.options.vertical === false) {
      targetLeft = -targetLeft;
    }
    if (_.transformsEnabled === false) {
      if (_.options.vertical === false) {
        _.$slideTrack.animate({
          left: targetLeft
        }, _.options.speed, _.options.easing, callback);
      }
      else {
        _.$slideTrack.animate({
          top: targetLeft
        }, _.options.speed, _.options.easing, callback);
      }

    }
    else {

      if (_.cssTransitions === false) {

        $({
          animStart: _.currentLeft
        }).animate({
          animStart: targetLeft
        }, {
          duration: _.options.speed,
          easing: _.options.easing,
          step: function (now) {
            if (_.options.vertical === false) {
              animProps[_.animType] = 'translate(' +
              now + 'px, 0px)';
              _.$slideTrack.css(animProps);
            }
            else {
              animProps[_.animType] = 'translate(0px,' +
              now + 'px)';
              _.$slideTrack.css(animProps);
            }
          },
          complete: function () {
            if (callback) {
              callback.call();
            }
          }
        });

      }
      else {

        _.applyTransition();

        if (_.options.vertical === false) {
          animProps[_.animType] = 'translate3d(' + targetLeft + 'px, 0px, 0px)';
        }
        else {
          animProps[_.animType] = 'translate3d(0px,' + targetLeft + 'px, 0px)';
        }
        _.$slideTrack.css(animProps);

        if (callback) {
          setTimeout(function () {

            _.disableTransition();

            callback.call();
          }, _.options.speed);
        }

      }

    }

  };

  Slick.prototype.asNavFor = function (index) {
    var _ = this, asNavFor = _.options.asNavFor != null ? $(_.options.asNavFor).getSlick() : null;
    if (asNavFor != null) {
      asNavFor.slideHandler(index, true);
    }
  };

  Slick.prototype.applyTransition = function (slide) {

    var _ = this,
      transition = {};

    if (_.options.fade === false) {
      transition[_.transitionType] = _.transformType + ' ' + _.options.speed + 'ms ' + _.options.cssEase;
    }
    else {
      transition[_.transitionType] = 'opacity ' + _.options.speed + 'ms ' + _.options.cssEase;
    }

    if (_.options.fade === false) {
      _.$slideTrack.css(transition);
    }
    else {
      _.$slides.eq(slide).css(transition);
    }

  };

  Slick.prototype.autoPlay = function () {

    var _ = this;

    if (_.autoPlayTimer) {
      clearInterval(_.autoPlayTimer);
    }

    if (_.slideCount > _.options.slidesToShow && _.paused !== true) {
      _.autoPlayTimer = setInterval(_.autoPlayIterator,
        _.options.autoplaySpeed);
    }

  };

  Slick.prototype.autoPlayClear = function () {

    var _ = this;
    if (_.autoPlayTimer) {
      clearInterval(_.autoPlayTimer);
    }

  };

  Slick.prototype.autoPlayIterator = function () {

    var _ = this;

    if (_.options.infinite === false) {

      if (_.direction === 1) {

        if ((_.currentSlide + 1) === _.slideCount -
          1) {
          _.direction = 0;
        }

        _.slideHandler(_.currentSlide + _.options.slidesToScroll);

      }
      else {

        if ((_.currentSlide - 1 === 0)) {

          _.direction = 1;

        }

        _.slideHandler(_.currentSlide - _.options.slidesToScroll);

      }

    }
    else {

      _.slideHandler(_.currentSlide + _.options.slidesToScroll);

    }

  };

  Slick.prototype.buildArrows = function () {

    var _ = this;

    if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

      _.$prevArrow = $(_.options.prevArrow);
      _.$nextArrow = $(_.options.nextArrow);

      if (_.htmlExpr.test(_.options.prevArrow)) {
        _.$prevArrow.appendTo(_.options.appendArrows);
      }

      if (_.htmlExpr.test(_.options.nextArrow)) {
        _.$nextArrow.appendTo(_.options.appendArrows);
      }

      if (_.options.infinite !== true) {
        _.$prevArrow.addClass('slick-disabled');
      }

    }

  };

  Slick.prototype.buildDots = function () {

    var _ = this,
      i, dotString, appendPoint;

    if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

      dotString = '<ul class="' + _.options.dotsClass + '">';

      for (i = 0; i <= _.getDotCount(); i += 1) {
        dotString += '<li>' + _.options.customPaging.call(this, _, i) + '</li>';
      }

      dotString += '</ul>';

      appendPoint = _.$slider;
      if (typeof _.options.appendDots == 'string') {
        appendPoint = _.$slider.find(_.options.appendDots);
      }

      _.$dots = $(dotString).appendTo(appendPoint);

      _.$dots.find('li:eq(0)').addClass('slick-active');

    }

  };

  Slick.prototype.buildOut = function () {

    var _ = this;

    _.$slides = _.$slider.children(_.options.slide +
    ':not(.slick-cloned)').addClass(
      'slick-slide');
    _.slideCount = _.$slides.length;

    _.$slides.each(function (index, element) {
      $(element).attr("index", index);
    });

    _.$slidesCache = _.$slides;

    _.$slider.addClass('slick-slider');

    if (_.$slideTrack == null) {
      _.$slideTrack = $('<div class="slick-track"/>');
    }

    _.$slideTrack.append(_.$slides);

    if (_.$list == null) {
      _.$list = $('<div class="slick-list"/>');
    }

    _.$list.append(_.$slideTrack);
    _.$list.appendTo(_.$slider);

    /**
    _.$slideTrack = (_.slideCount === 0) ?
      $('<div class="slick-track"/>').appendTo(_.$slider) :
      _.$slides.wrapAll('<div class="slick-track"/>').parent();

    _.$list = _.$slideTrack.wrap(
      '<div class="slick-list"/>').parent();
    **/
    _.$slideTrack.css('opacity', 0);

    if (_.options.centerMode === true) {
      _.options.slidesToScroll = 1;
    }

    $('img[data-lazy]', _.$slider).not('[src]').addClass('slick-loading');

    _.setupInfinite();

    _.buildArrows();

    _.buildDots();

    _.updateDots();

    if (_.options.accessibility === true) {
      _.$list.prop('tabIndex', 0);
    }

    _.setSlideClasses(typeof this.currentSlide === 'number' ? this.currentSlide : 0);

    if (_.options.draggable === true) {
      _.$list.addClass('draggable');
    }

  };

  Slick.prototype.checkResponsive = function () {

    var _ = this,
      breakpoint, targetBreakpoint, respondToWidth;
    var sliderWidth = _.$slider.width();
    var windowWidth = window.innerWidth || $(window).width();
    if (_.respondTo === "window") {
      respondToWidth = windowWidth;
    }
    else {
      if (_.respondTo === "slider") {
        respondToWidth = sliderWidth;
      }
      else {
        if (_.respondTo === "min") {
          respondToWidth = Math.min(windowWidth, sliderWidth);
        }
      }
    }

    if (_.originalSettings.responsive && _.originalSettings
        .responsive.length > -1 && _.originalSettings.responsive !== null) {

      targetBreakpoint = null;

      for (breakpoint in _.breakpoints) {
        if (_.breakpoints.hasOwnProperty(breakpoint)) {
          if (respondToWidth < _.breakpoints[breakpoint]) {
            targetBreakpoint = _.breakpoints[breakpoint];
          }
        }
      }

      if (targetBreakpoint !== null) {
        if (_.activeBreakpoint !== null) {
          if (targetBreakpoint !== _.activeBreakpoint) {
            _.activeBreakpoint =
              targetBreakpoint;
            _.options = $.extend({}, _.originalSettings,
              _.breakpointSettings[
                targetBreakpoint]);
            _.refresh();
          }
        }
        else {
          _.activeBreakpoint = targetBreakpoint;
          _.options = $.extend({}, _.originalSettings,
            _.breakpointSettings[
              targetBreakpoint]);
          _.refresh();
        }
      }
      else {
        if (_.activeBreakpoint !== null) {
          _.activeBreakpoint = null;
          _.options = _.originalSettings;
          _.refresh();
        }
      }

    }

  };

  Slick.prototype.changeSlide = function (event, dontAnimate) {

    var _ = this,
      $target = $(event.target),
      indexOffset, slideOffset, unevenOffset, navigables, prevNavigable;

    // If target is a link, prevent default action.
    $target.is('a') && event.preventDefault();

    unevenOffset = (_.slideCount % _.options.slidesToScroll !== 0);
    indexOffset = unevenOffset ? 0 : (_.slideCount - _.currentSlide) % _.options.slidesToScroll;

    switch (event.data.message) {

      case 'previous':
        slideOffset = indexOffset === 0 ? _.options.slidesToScroll : _.options.slidesToShow - indexOffset;
        if (_.slideCount > _.options.slidesToShow) {
          _.slideHandler(_.currentSlide - slideOffset, false, dontAnimate);
        }
        break;

      case 'next':
        slideOffset = indexOffset === 0 ? _.options.slidesToScroll : indexOffset;
        if (_.slideCount > _.options.slidesToShow) {
          _.slideHandler(_.currentSlide + slideOffset, false, dontAnimate);
        }
        break;

      case 'index':
        var index = event.data.index === 0 ? 0 :
        event.data.index || $(event.target).parent().index() * _.options.slidesToScroll;

        navigables = _.getNavigableIndexes();
        prevNavigable = 0;
        if (navigables[index] && navigables[index] === index) {
          if (index > navigables[navigables.length - 1]) {
            index = navigables[navigables.length - 1];
          }
          else {
            for (var n in navigables) {
              if (index < navigables[n]) {
                index = prevNavigable;
                break;
              }
              prevNavigable = navigables[n];
            }
          }
        }
        _.slideHandler(index, false, dontAnimate);

      default:
        return;
    }

  };

  Slick.prototype.clickHandler = function (event) {

    var _ = this;

    if (_.shouldClick === false) {
      event.stopImmediatePropagation();
      event.stopPropagation();
      event.preventDefault();
    }

  }

  Slick.prototype.destroy = function () {

    var _ = this;

    _.autoPlayClear();

    _.touchObject = {};

    $('.slick-cloned', _.$slider).remove();
    if (_.$dots) {
      _.$dots.remove();
    }
    if (_.$prevArrow && (typeof _.options.prevArrow !== 'object')) {
      _.$prevArrow.remove();
    }
    if (_.$nextArrow && (typeof _.options.nextArrow !== 'object')) {
      _.$nextArrow.remove();
    }

    $('.slick-track', _.$slider).unwrap().children().unwrap();

    if ($('.slick-track', _.$slider).length != 0 && $('.slick-track', _.$slider).children().length == 0) {
      $('.slick-track', _.$slider).remove();
    }

    if ($('.slick-list', _.$slider).length != 0 && $('.slick-list', _.$slider).children().length == 0) {
      $('.slick-list', _.$slider).remove();
    }
    _.$slides && _.$slides.removeClass(
      'slick-slide slick-active slick-center slick-visible')
      .removeAttr('index')
      .css({
        position: '',
        left: '',
        top: '',
        zIndex: '',
        opacity: '',
        width: ''
      });

    _.$slider && _.$slider.removeClass('slick-slider slick-initialized');

    _.$list && _.$list.off('.slick');
    $(window).off('.slick-' + _.instanceUid);
    $(document).off('.slick-' + _.instanceUid);


  };

  Slick.prototype.disableTransition = function (slide) {

    var _ = this,
      transition = {};

    transition[_.transitionType] = "";

    if (_.options.fade === false) {
      _.$slideTrack.css(transition);
    }
    else {
      _.$slides.eq(slide).css(transition);
    }

  };

  Slick.prototype.fadeSlide = function (oldSlide, slideIndex, callback) {

    var _ = this;

    if (_.cssTransitions === false) {

      _.$slides.eq(slideIndex).css({
        zIndex: 1000
      });

      _.$slides.eq(slideIndex).animate({
        opacity: 1
      }, _.options.speed, _.options.easing, callback);

      _.$slides.eq(oldSlide).animate({
        opacity: 0
      }, _.options.speed, _.options.easing);

    }
    else {

      _.applyTransition(slideIndex);
      _.applyTransition(oldSlide);

      _.$slides.eq(slideIndex).css({
        opacity: 1,
        zIndex: 1000
      });

      _.$slides.eq(oldSlide).css({
        opacity: 0
      });

      if (callback) {
        setTimeout(function () {

          _.disableTransition(slideIndex);
          _.disableTransition(oldSlide);

          callback.call();
        }, _.options.speed);
      }

    }

  };

  Slick.prototype.filterSlides = function (filter) {

    var _ = this;

    if (filter !== null) {

      _.unload();

      _.$slideTrack.children(this.options.slide).detach();

      _.$slidesCache.filter(filter).appendTo(_.$slideTrack);

      _.reinit();

    }

  };

  Slick.prototype.getCurrent = function () {

    var _ = this;

    return _.currentSlide;

  };

  Slick.prototype.getDotCount = function () {

    var _ = this;

    var breakPoint = 0;
    var counter = 0;
    var pagerQty = 0;

    if (_.options.infinite === true) {
      pagerQty = Math.ceil(_.slideCount / _.options.slidesToScroll);
    }
    else {
      while (breakPoint < _.slideCount) {
        ++pagerQty;
        breakPoint = counter + _.options.slidesToShow;
        counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
      }
    }

    return pagerQty - 1;

  };

  Slick.prototype.getLeft = function (slideIndex) {

    var _ = this,
      targetLeft,
      verticalHeight,
      verticalOffset = 0,
      slideWidth,
      targetSlide;

    _.slideOffset = 0;
    verticalHeight = _.$slides.first().outerHeight();

    if (_.options.infinite === true) {
      if (_.slideCount > _.options.slidesToShow) {
        _.slideOffset = (_.slideWidth * _.options.slidesToShow) * -1;
        verticalOffset = (verticalHeight * _.options.slidesToShow) * -1;
      }
      if (_.slideCount % _.options.slidesToScroll !== 0) {
        if (slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) {
          if (slideIndex > _.slideCount) {
            _.slideOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * _.slideWidth) * -1;
            verticalOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * verticalHeight) * -1;
          }
          else {
            _.slideOffset = ((_.slideCount % _.options.slidesToScroll) * _.slideWidth) * -1;
            verticalOffset = ((_.slideCount % _.options.slidesToScroll) * verticalHeight) * -1;
          }
        }
      }
    }
    else {
      if (slideIndex + _.options.slidesToShow > _.slideCount) {
        _.slideOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * _.slideWidth;
        verticalOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * verticalHeight;
      }
    }

    if (_.slideCount <= _.options.slidesToShow) {
      _.slideOffset = 0;
      verticalOffset = 0;
    }

    if (_.options.centerMode === true && _.options.infinite === true) {
      _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth;
    }
    else {
      if (_.options.centerMode === true) {
        _.slideOffset = 0;
        _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);
      }
    }

    if (_.options.vertical === false) {
      targetLeft = ((slideIndex * _.slideWidth) * -1) + _.slideOffset;
    }
    else {
      targetLeft = ((slideIndex * verticalHeight) * -1) + verticalOffset;
    }

    if (_.options.variableWidth === true) {

      if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
        targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
      }
      else {
        targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow);
      }
      targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
      if (_.options.centerMode === true) {
        if (_.options.infinite === false) {
          targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
        }
        else {
          targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow + 1);
        }
        targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
        targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;
      }
    }

    // 1680

    return targetLeft;

  };

  Slick.prototype.getNavigableIndexes = function () {

    var _ = this;

    var breakPoint = 0;
    var counter = 0;
    var indexes = [];

    while (breakPoint < _.slideCount) {
      indexes.push(breakPoint);
      breakPoint = counter + _.options.slidesToScroll;
      counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
    }

    return indexes;

  };

  Slick.prototype.getSlideCount = function () {

    var _ = this, slidesTraversed;

    if (_.options.swipeToSlide === true) {
      var swipedSlide = null;
      _.$slideTrack.find('.slick-slide').each(function (index, slide) {
        if (slide.offsetLeft + ($(slide).outerWidth() / 2) > (_.swipeLeft * -1)) {
          swipedSlide = slide;
          return false;
        }
      });
      slidesTraversed = Math.abs($(swipedSlide).attr('index') - _.currentSlide);
      return slidesTraversed;
    }
    else {
      return _.options.slidesToScroll;
    }

  };

  Slick.prototype.init = function () {

    var _ = this;

    if (!$(_.$slider).hasClass('slick-initialized')) {

      $(_.$slider).addClass('slick-initialized');
      _.buildOut();
      _.setProps();
      _.startLoad();
      _.loadSlider();
      _.initializeEvents();
      _.updateArrows();
      _.updateDots();
    }

    if (_.options.onInit !== null) {
      _.options.onInit.call(this, _);
    }

  };

  Slick.prototype.initArrowEvents = function () {

    var _ = this;

    if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
      _.$prevArrow.on('click.slick', {
        message: 'previous'
      }, _.changeSlide);
      _.$nextArrow.on('click.slick', {
        message: 'next'
      }, _.changeSlide);
    }

  };

  Slick.prototype.initDotEvents = function () {

    var _ = this;

    if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
      $('li', _.$dots).on('click.slick', {
        message: 'index'
      }, _.changeSlide);
    }

    if (_.options.dots === true && _.options.pauseOnDotsHover === true && _.options.autoplay === true) {
      $('li', _.$dots)
        .on('mouseenter.slick', function () {
          _.paused = true;
          _.autoPlayClear();
        })
        .on('mouseleave.slick', function () {
          _.paused = false;
          _.autoPlay();
        });
    }

  };

  Slick.prototype.initializeEvents = function () {

    var _ = this;

    _.initArrowEvents();

    _.initDotEvents();

    _.$list.on('touchstart.slick mousedown.slick', {
      action: 'start'
    }, _.swipeHandler);
    _.$list.on('touchmove.slick mousemove.slick', {
      action: 'move'
    }, _.swipeHandler);
    _.$list.on('touchend.slick mouseup.slick', {
      action: 'end'
    }, _.swipeHandler);
    _.$list.on('touchcancel.slick mouseleave.slick', {
      action: 'end'
    }, _.swipeHandler);

    _.$list.on('click.slick', _.clickHandler);

    if (_.options.pauseOnHover === true && _.options.autoplay === true) {
      _.$list.on('mouseenter.slick', function () {
        _.paused = true;
        _.autoPlayClear();
      });
      _.$list.on('mouseleave.slick', function () {
        _.paused = false;
        _.autoPlay();
      });
    }

    if (_.options.accessibility === true) {
      _.$list.on('keydown.slick', _.keyHandler);
    }

    if (_.options.focusOnSelect === true) {
      $(_.options.slide, _.$slideTrack).on('click.slick', _.selectHandler);
    }

    $(window).on('orientationchange.slick.slick-' + _.instanceUid, function () {
      _.checkResponsive();
      _.setPosition();
    });

    $(window).on('resize.slick.slick-' + _.instanceUid, function () {
      if ($(window).width() !== _.windowWidth) {
        clearTimeout(_.windowDelay);
        _.windowDelay = window.setTimeout(function () {
          _.windowWidth = $(window).width();
          _.checkResponsive();
          _.setPosition();
        }, 50);
      }
    });

    $('*[draggable!=true]', _.$slideTrack).on('dragstart', function (e) {
      e.preventDefault();
    })

    $(window).on('load.slick.slick-' + _.instanceUid, _.setPosition);
    $(document).on('ready.slick.slick-' + _.instanceUid, _.setPosition);

  };

  Slick.prototype.initUI = function () {

    var _ = this;

    if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

      _.$prevArrow.show();
      _.$nextArrow.show();

    }

    if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

      _.$dots.show();

    }

    if (_.options.autoplay === true) {

      _.autoPlay();

    }

  };

  Slick.prototype.keyHandler = function (event) {

    var _ = this;

    if (event.keyCode === 37 && _.options.accessibility === true) {
      _.changeSlide({
        data: {
          message: 'previous'
        }
      });
    }
    else {
      if (event.keyCode === 39 && _.options.accessibility === true) {
        _.changeSlide({
          data: {
            message: 'next'
          }
        });
      }
    }

  };

  Slick.prototype.lazyLoad = function () {

    var _ = this,
      loadRange, cloneRange, rangeStart, rangeEnd;

    function loadImages(imagesScope) {
      $('img[data-lazy]', imagesScope).each(function () {
        var image = $(this),
          imageSource = $(this).attr('data-lazy');

        image
          .on("load",function () {
            image.animate({opacity: 1}, 200);
          })
          .css({opacity: 0})
          .attr('src', imageSource)
          .removeAttr('data-lazy')
          .removeClass('slick-loading');
      });
    }

    if (_.options.centerMode === true) {
      if (_.options.infinite === true) {
        rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);
        rangeEnd = rangeStart + _.options.slidesToShow + 2;
      }
      else {
        rangeStart = Math.max(0, _.currentSlide - (_.options.slidesToShow / 2 + 1));
        rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;
      }
    }
    else {
      rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide;
      rangeEnd = rangeStart + _.options.slidesToShow;
      if (_.options.fade === true) {
        if (rangeStart > 0) {
          rangeStart--;
        }
        if (rangeEnd <= _.slideCount) {
          rangeEnd++;
        }
      }
    }

    loadRange = _.$slider.find('.slick-slide').slice(rangeStart, rangeEnd);
    loadImages(loadRange);

    if (_.slideCount <= _.options.slidesToShow) {
      cloneRange = _.$slider.find('.slick-slide')
      loadImages(cloneRange)
    }
    else {
      if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {
        cloneRange = _.$slider.find('.slick-cloned').slice(0, _.options.slidesToShow);
        loadImages(cloneRange)
      }
      else {
        if (_.currentSlide === 0) {
          cloneRange = _.$slider.find('.slick-cloned').slice(_.options.slidesToShow * -1);
          loadImages(cloneRange);
        }
      }
    }

  };

  Slick.prototype.loadSlider = function () {

    var _ = this;

    _.setPosition();

    _.$slideTrack.css({
      opacity: 1
    });

    _.$slider.removeClass('slick-loading');

    _.initUI();

    if (_.options.lazyLoad === 'progressive') {
      _.progressiveLazyLoad();
    }

  };

  Slick.prototype.postSlide = function (index) {

    var _ = this;

    if (_.options.onAfterChange !== null) {
      _.options.onAfterChange.call(this, _, index);
    }

    _.animating = false;

    _.setPosition();

    _.swipeLeft = null;

    if (_.options.autoplay === true && _.paused === false) {
      _.autoPlay();
    }

  };

  Slick.prototype.progressiveLazyLoad = function () {

    var _ = this,
      imgCount, targetImage;

    imgCount = $('img[data-lazy]', _.$slider).length;

    if (imgCount > 0) {
      targetImage = $('img[data-lazy]', _.$slider).first();
      targetImage.attr('src', targetImage.attr('data-lazy')).removeClass('slick-loading').on("load", function () {
        targetImage.removeAttr('data-lazy');
        _.progressiveLazyLoad();
      })
        .on("error", function () {
          targetImage.removeAttr('data-lazy');
          _.progressiveLazyLoad();
        });
    }

  };

  Slick.prototype.refresh = function () {

    var _ = this,
      currentSlide = _.currentSlide;

    _.destroy();

    $.extend(_, _.initials);

    _.init();

    _.changeSlide({
      data: {
        message: 'index',
        index: currentSlide
      }
    }, true);

  };

  Slick.prototype.reinit = function () {

    var _ = this;

    _.$slides = _.$slideTrack.children(_.options.slide).addClass(
      'slick-slide');

    _.slideCount = _.$slides.length;

    if (_.currentSlide >= _.slideCount && _.currentSlide !== 0) {
      _.currentSlide = _.currentSlide - _.options.slidesToScroll;
    }

    if (_.slideCount <= _.options.slidesToShow) {
      _.currentSlide = 0;
    }

    _.setProps();

    _.setupInfinite();

    _.buildArrows();

    _.updateArrows();

    _.initArrowEvents();

    _.buildDots();

    _.updateDots();

    _.initDotEvents();

    if (_.options.focusOnSelect === true) {
      $(_.options.slide, _.$slideTrack).on('click.slick', _.selectHandler);
    }

    _.setSlideClasses(0);

    _.setPosition();

    if (_.options.onReInit !== null) {
      _.options.onReInit.call(this, _);
    }

  };

  Slick.prototype.removeSlide = function (index, removeBefore, removeAll) {

    var _ = this;

    if (typeof(index) === 'boolean') {
      removeBefore = index;
      index = removeBefore === true ? 0 : _.slideCount - 1;
    }
    else {
      index = removeBefore === true ? --index : index;
    }

    if (_.slideCount < 1 || index < 0 || index > _.slideCount - 1) {
      return false;
    }

    _.unload();

    if (removeAll === true) {
      _.$slideTrack.children().remove();
    }
    else {
      _.$slideTrack.children(this.options.slide).eq(index).remove();
    }

    _.$slides = _.$slideTrack.children(this.options.slide);

    _.$slideTrack.children(this.options.slide).detach();

    _.$slideTrack.append(_.$slides);

    _.$slidesCache = _.$slides;

    _.reinit();

  };

  Slick.prototype.setCSS = function (position) {

    var _ = this,
      positionProps = {}, x, y;

    if (_.options.rtl === true) {
      position = -position;
    }
    x = _.positionProp == 'left' ? position + 'px' : '0px';
    y = _.positionProp == 'top' ? position + 'px' : '0px';

    positionProps[_.positionProp] = position;

    if (_.transformsEnabled === false) {
      _.$slideTrack.css(positionProps);
    }
    else {
      positionProps = {};
      if (_.cssTransitions === false) {
        positionProps[_.animType] = 'translate(' + x + ', ' + y + ')';
        _.$slideTrack.css(positionProps);
      }
      else {
        positionProps[_.animType] = 'translate3d(' + x + ', ' + y + ', 0px)';
        _.$slideTrack.css(positionProps);
      }
    }

  };

  Slick.prototype.setDimensions = function () {

    var _ = this;

    if (_.options.vertical === false) {
      if (_.options.centerMode === true) {
        _.$list.css({
          padding: ('0px ' + _.options.centerPadding)
        });
      }
    }
    else {
      _.$list.height(_.$slides.first().outerHeight(true) * _.options.slidesToShow);
      if (_.options.centerMode === true) {
        _.$list.css({
          padding: (_.options.centerPadding + ' 0px')
        });
      }
    }

    _.listWidth = _.$list.width();
    _.listHeight = _.$list.height();


    if (_.options.vertical === false && _.options.variableWidth === false) {
      _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);
      _.$slideTrack.width(Math.ceil((_.slideWidth * _.$slideTrack.children('.slick-slide').length)));

    }
    else {
      if (_.options.variableWidth === true) {
        var trackWidth = 0;
        _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);
        _.$slideTrack.children('.slick-slide').each(function () {
          trackWidth += Math.ceil($(this).outerWidth(true));
        });
        _.$slideTrack.width(Math.ceil(trackWidth) + 1);
      }
      else {
        _.slideWidth = Math.ceil(_.listWidth);
        _.$slideTrack.height(Math.ceil((_.$slides.first().outerHeight(true) * _.$slideTrack.children('.slick-slide').length)));
      }
    }

    var offset = _.$slides.first().outerWidth(true) - _.$slides.first().width();
    if (_.options.variableWidth === false) {
      _.$slideTrack.children('.slick-slide').width(_.slideWidth - offset);
    }

  };

  Slick.prototype.setFade = function () {

    var _ = this,
      targetLeft;

    _.$slides.each(function (index, element) {
      targetLeft = (_.slideWidth * index) * -1;
      if (_.options.rtl === true) {
        $(element).css({
          position: 'relative',
          right: targetLeft,
          top: 0,
          zIndex: 800,
          opacity: 0
        });
      }
      else {
        $(element).css({
          position: 'relative',
          left: targetLeft,
          top: 0,
          zIndex: 800,
          opacity: 0
        });
      }
    });

    _.$slides.eq(_.currentSlide).css({
      zIndex: 900,
      opacity: 1
    });

  };

  Slick.prototype.setHeight = function () {

    var _ = this;

    if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
      var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
      _.$list.css('height', targetHeight);
    }

  };

  Slick.prototype.setPosition = function () {

    var _ = this;

    _.setDimensions();

    _.setHeight();

    if (_.options.fade === false) {
      _.setCSS(_.getLeft(_.currentSlide));
    }
    else {
      _.setFade();
    }

    if (_.options.onSetPosition !== null) {
      _.options.onSetPosition.call(this, _);
    }

  };

  Slick.prototype.setProps = function () {

    var _ = this,
      bodyStyle = document.body.style;

    _.positionProp = _.options.vertical === true ? 'top' : 'left';

    if (_.positionProp === 'top') {
      _.$slider.addClass('slick-vertical');
    }
    else {
      _.$slider.removeClass('slick-vertical');
    }

    if (bodyStyle.WebkitTransition !== undefined ||
      bodyStyle.MozTransition !== undefined ||
      bodyStyle.msTransition !== undefined) {
      if (_.options.useCSS === true) {
        _.cssTransitions = true;
      }
    }

    if (bodyStyle.OTransform !== undefined) {
      _.animType = 'OTransform';
      _.transformType = "-o-transform";
      _.transitionType = 'OTransition';
      if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) {
        _.animType = false;
      }
    }
    if (bodyStyle.MozTransform !== undefined) {
      _.animType = 'MozTransform';
      _.transformType = "-moz-transform";
      _.transitionType = 'MozTransition';
      if (bodyStyle.perspectiveProperty === undefined && bodyStyle.MozPerspective === undefined) {
        _.animType = false;
      }
    }
    if (bodyStyle.webkitTransform !== undefined) {
      _.animType = 'webkitTransform';
      _.transformType = "-webkit-transform";
      _.transitionType = 'webkitTransition';
      if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) {
        _.animType = false;
      }
    }
    if (bodyStyle.msTransform !== undefined) {
      _.animType = 'msTransform';
      _.transformType = "-ms-transform";
      _.transitionType = 'msTransition';
      if (bodyStyle.msTransform === undefined) {
        _.animType = false;
      }
    }
    if (bodyStyle.transform !== undefined && _.animType !== false) {
      _.animType = 'transform';
      _.transformType = "transform";
      _.transitionType = 'transition';
    }
    _.transformsEnabled = (_.animType !== null && _.animType !== false);

  };


  Slick.prototype.setSlideClasses = function (index) {

    var _ = this,
      centerOffset, allSlides, indexOffset, remainder;

    _.$slider.find('.slick-slide').removeClass('slick-active').removeClass('slick-center');
    allSlides = _.$slider.find('.slick-slide');

    if (_.options.centerMode === true) {

      centerOffset = Math.floor(_.options.slidesToShow / 2);

      if (_.options.infinite === true) {

        if (index >= centerOffset && index <= (_.slideCount - 1) - centerOffset) {
          _.$slides.slice(index - centerOffset, index + centerOffset + 1).addClass('slick-active');
        }
        else {
          indexOffset = _.options.slidesToShow + index;
          allSlides.slice(indexOffset - centerOffset + 1, indexOffset + centerOffset + 2).addClass('slick-active');
        }

        if (index === 0) {
          allSlides.eq(allSlides.length - 1 - _.options.slidesToShow).addClass('slick-center');
        }
        else {
          if (index === _.slideCount - 1) {
            allSlides.eq(_.options.slidesToShow).addClass('slick-center');
          }
        }

      }

      _.$slides.eq(index).addClass('slick-center');

    }
    else {

      if (index >= 0 && index <= (_.slideCount - _.options.slidesToShow)) {
        _.$slides.slice(index, index + _.options.slidesToShow).addClass('slick-active');
      }
      else {
        if (allSlides.length <= _.options.slidesToShow) {
          allSlides.addClass('slick-active');
        }
        else {
          remainder = _.slideCount % _.options.slidesToShow;
          indexOffset = _.options.infinite === true ? _.options.slidesToShow + index : index;
          if (_.options.slidesToShow == _.options.slidesToScroll && (_.slideCount - index) < _.options.slidesToShow) {
            allSlides.slice(indexOffset - (_.options.slidesToShow - remainder), indexOffset + remainder).addClass('slick-active');
          }
          else {
            allSlides.slice(indexOffset, indexOffset + _.options.slidesToShow).addClass('slick-active');
          }
        }
      }

    }

    if (_.options.lazyLoad === 'ondemand') {
      _.lazyLoad();
    }

  };

  Slick.prototype.setupInfinite = function () {

    var _ = this,
      i, slideIndex, infiniteCount;

    if (_.options.fade === true) {
      _.options.centerMode = false;
    }

    if (_.options.infinite === true && _.options.fade === false) {

      slideIndex = null;

      if (_.slideCount > _.options.slidesToShow) {

        if (_.options.centerMode === true) {
          infiniteCount = _.options.slidesToShow + 1;
        }
        else {
          infiniteCount = _.options.slidesToShow;
        }

        for (i = _.slideCount; i > (_.slideCount -
        infiniteCount); i -= 1) {
          slideIndex = i - 1;
          $(_.$slides[slideIndex]).clone(true).attr('id', '')
            .attr('index', slideIndex - _.slideCount)
            .prependTo(_.$slideTrack).addClass('slick-cloned');
        }
        for (i = 0; i < infiniteCount; i += 1) {
          slideIndex = i;
          $(_.$slides[slideIndex]).clone(true).attr('id', '')
            .attr('index', slideIndex + _.slideCount)
            .appendTo(_.$slideTrack).addClass('slick-cloned');
        }
        _.$slideTrack.find('.slick-cloned').find('[id]').each(function () {
          $(this).attr('id', '');
        });

      }

    }

  };

  Slick.prototype.selectHandler = function (event) {

    var _ = this;
    var index = parseInt($(event.target).parents('.slick-slide').attr("index"));
    if (!index) {
      index = 0;
    }

    if (_.slideCount <= _.options.slidesToShow) {
      _.$slider.find('.slick-slide').removeClass('slick-active');
      _.$slides.eq(index).addClass('slick-active');
      if (_.options.centerMode === true) {
        _.$slider.find('.slick-slide').removeClass('slick-center');
        _.$slides.eq(index).addClass('slick-center');
      }
      _.asNavFor(index);
      return;
    }
    _.slideHandler(index);

  };

  Slick.prototype.slideHandler = function (index, sync, dontAnimate) {

    var targetSlide, animSlide, oldSlide, slideLeft, unevenOffset, targetLeft = null,
      _ = this;

    sync = sync || false;

    if (_.animating === true && _.options.waitForAnimate === true) {
      return;
    }

    if (_.options.fade === true && _.currentSlide === index) {
      return;
    }

    if (_.slideCount <= _.options.slidesToShow) {
      return;
    }

    if (sync === false) {
      _.asNavFor(index);
    }

    targetSlide = index;
    targetLeft = _.getLeft(targetSlide);
    slideLeft = _.getLeft(_.currentSlide);

    _.currentLeft = _.swipeLeft === null ? slideLeft : _.swipeLeft;

    if (_.options.infinite === false && _.options.centerMode === false && (index < 0 || index > _.getDotCount() * _.options.slidesToScroll)) {
      if (_.options.fade === false) {
        targetSlide = _.currentSlide;
        if (dontAnimate !== true) {
          _.animateSlide(slideLeft, function () {
            _.postSlide(targetSlide);
          });
        }
        else {
          _.postSlide(targetSlide);
        }
      }
      return;
    }
    else {
      if (_.options.infinite === false && _.options.centerMode === true && (index < 0 || index > (_.slideCount - _.options.slidesToScroll))) {
        if (_.options.fade === false) {
          targetSlide = _.currentSlide;
          if (dontAnimate !== true) {
            _.animateSlide(slideLeft, function () {
              _.postSlide(targetSlide);
            });
          }
          else {
            _.postSlide(targetSlide);
          }
        }
        return;
      }
    }

    if (_.options.autoplay === true) {
      clearInterval(_.autoPlayTimer);
    }

    if (targetSlide < 0) {
      if (_.slideCount % _.options.slidesToScroll !== 0) {
        animSlide = _.slideCount - (_.slideCount % _.options.slidesToScroll);
      }
      else {
        animSlide = _.slideCount + targetSlide;
      }
    }
    else {
      if (targetSlide >= _.slideCount) {
        if (_.slideCount % _.options.slidesToScroll !== 0) {
          animSlide = 0;
        }
        else {
          animSlide = targetSlide - _.slideCount;
        }
      }
      else {
        animSlide = targetSlide;
      }
    }

    _.animating = true;

    if (_.options.onBeforeChange !== null && index !== _.currentSlide) {
      _.options.onBeforeChange.call(this, _, _.currentSlide, animSlide);
    }

    oldSlide = _.currentSlide;
    _.currentSlide = animSlide;

    _.setSlideClasses(_.currentSlide);

    _.updateDots();
    _.updateArrows();

    if (_.options.fade === true) {
      if (dontAnimate !== true) {
        _.fadeSlide(oldSlide, animSlide, function () {
          _.postSlide(animSlide);
        });
      }
      else {
        _.postSlide(animSlide);
      }
      return;
    }

    if (dontAnimate !== true) {
      _.animateSlide(targetLeft, function () {
        _.postSlide(animSlide);
      });
    }
    else {
      _.postSlide(animSlide);
    }

  };

  Slick.prototype.startLoad = function () {

    var _ = this;

    if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

      _.$prevArrow.hide();
      _.$nextArrow.hide();

    }

    if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

      _.$dots.hide();

    }

    _.$slider.addClass('slick-loading');

  };

  Slick.prototype.swipeDirection = function () {

    var xDist, yDist, r, swipeAngle, _ = this;

    xDist = _.touchObject.startX - _.touchObject.curX;
    yDist = _.touchObject.startY - _.touchObject.curY;
    r = Math.atan2(yDist, xDist);

    swipeAngle = Math.round(r * 180 / Math.PI);
    if (swipeAngle < 0) {
      swipeAngle = 360 - Math.abs(swipeAngle);
    }

    if ((swipeAngle <= 45) && (swipeAngle >= 0)) {
      return (_.options.rtl === false ? 'left' : 'right');
    }
    if ((swipeAngle <= 360) && (swipeAngle >= 315)) {
      return (_.options.rtl === false ? 'left' : 'right');
    }
    if ((swipeAngle >= 135) && (swipeAngle <= 225)) {
      return (_.options.rtl === false ? 'right' : 'left');
    }

    return 'vertical';

  };

  Slick.prototype.swipeEnd = function (event) {

    var _ = this, slideCount;

    _.dragging = false;

    _.shouldClick = (_.touchObject.swipeLength > 10) ? false : true;

    if (_.touchObject.curX === undefined) {
      return false;
    }

    if (_.touchObject.swipeLength >= _.touchObject.minSwipe) {

      switch (_.swipeDirection()) {
        case 'left':
          _.slideHandler(_.currentSlide + _.getSlideCount());
          _.currentDirection = 0;
          _.touchObject = {};
          break;

        case 'right':
          _.slideHandler(_.currentSlide - _.getSlideCount());
          _.currentDirection = 1;
          _.touchObject = {};
          break;
      }
    }
    else {
      if (_.touchObject.startX !== _.touchObject.curX) {
        _.slideHandler(_.currentSlide);
        _.touchObject = {};
      }
    }

  };

  Slick.prototype.swipeHandler = function (event) {

    var _ = this;

    if ((_.options.swipe === false) || ('ontouchend' in document && _.options.swipe === false)) {
      return;
    }
    else {
      if (_.options.draggable === false && event.type.indexOf('mouse') !== -1) {
        return;
      }
    }

    _.touchObject.fingerCount = event.originalEvent && event.originalEvent.touches !== undefined ?
      event.originalEvent.touches.length : 1;

    _.touchObject.minSwipe = _.listWidth / _.options
      .touchThreshold;

    switch (event.data.action) {

      case 'start':
        _.swipeStart(event);
        break;

      case 'move':
        _.swipeMove(event);
        break;

      case 'end':
        _.swipeEnd(event);
        break;

    }

  };

  Slick.prototype.swipeMove = function (event) {

    var _ = this,
      curLeft, swipeDirection, positionOffset, touches;

    touches = event.originalEvent !== undefined ? event.originalEvent.touches : null;

    if (!_.dragging || touches && touches.length !== 1) {
      return false;
    }

    curLeft = _.getLeft(_.currentSlide);

    _.touchObject.curX = touches !== undefined ? touches[0].pageX : event.clientX;
    _.touchObject.curY = touches !== undefined ? touches[0].pageY : event.clientY;

    _.touchObject.swipeLength = Math.round(Math.sqrt(
      Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));

    swipeDirection = _.swipeDirection();

    if (swipeDirection === 'vertical') {
      return;
    }

    if (event.originalEvent !== undefined && _.touchObject.swipeLength > 4) {
      event.preventDefault();
    }

    positionOffset = (_.options.rtl === false ? 1 : -1) * (_.touchObject.curX > _.touchObject.startX ? 1 : -1);

    if (_.options.vertical === false) {
      _.swipeLeft = curLeft + _.touchObject.swipeLength * positionOffset;
    }
    else {
      _.swipeLeft = curLeft + (_.touchObject
        .swipeLength * (_.$list.height() / _.listWidth)) * positionOffset;
    }

    if (_.options.fade === true || _.options.touchMove === false) {
      return false;
    }

    if (_.animating === true) {
      _.swipeLeft = null;
      return false;
    }

    _.setCSS(_.swipeLeft);

  };

  Slick.prototype.swipeStart = function (event) {

    var _ = this,
      touches;

    if (_.touchObject.fingerCount !== 1 || _.slideCount <= _.options.slidesToShow) {
      _.touchObject = {};
      return false;
    }

    if (event.originalEvent !== undefined && event.originalEvent.touches !== undefined) {
      touches = event.originalEvent.touches[0];
    }

    _.touchObject.startX = _.touchObject.curX = touches !== undefined ? touches.pageX : event.clientX;
    _.touchObject.startY = _.touchObject.curY = touches !== undefined ? touches.pageY : event.clientY;

    _.dragging = true;

  };

  Slick.prototype.unfilterSlides = function () {

    var _ = this;

    if (_.$slidesCache !== null) {

      _.unload();

      _.$slideTrack.children(this.options.slide).detach();

      _.$slidesCache.appendTo(_.$slideTrack);

      _.reinit();

    }

  };

  Slick.prototype.unload = function () {

    var _ = this;

    $('.slick-cloned', _.$slider).remove();
    if (_.$dots) {
      _.$dots.remove();
    }
    if (_.$prevArrow && (typeof _.options.prevArrow !== 'object')) {
      _.$prevArrow.remove();
    }
    if (_.$nextArrow && (typeof _.options.nextArrow !== 'object')) {
      _.$nextArrow.remove();
    }
    _.$slides.removeClass(
      'slick-slide slick-active slick-visible').css('width', '');

  };

  Slick.prototype.updateArrows = function () {

    var _ = this, centerOffset;

    centerOffset = Math.floor(_.options.slidesToShow / 2)

    if (_.options.arrows === true && _.options.infinite !==
      true && _.slideCount > _.options.slidesToShow) {
      _.$prevArrow.removeClass('slick-disabled');
      _.$nextArrow.removeClass('slick-disabled');
      if (_.currentSlide === 0) {
        _.$prevArrow.addClass('slick-disabled');
        _.$nextArrow.removeClass('slick-disabled');
      }
      else {
        if (_.currentSlide >= _.slideCount - _.options.slidesToShow && _.options.centerMode === false) {
          _.$nextArrow.addClass('slick-disabled');
          _.$prevArrow.removeClass('slick-disabled');
        }
        else {
          if (_.currentSlide > _.slideCount - _.options.slidesToShow + centerOffset && _.options.centerMode === true) {
            _.$nextArrow.addClass('slick-disabled');
            _.$prevArrow.removeClass('slick-disabled');
          }
        }
      }
    }

  };

  Slick.prototype.updateDots = function () {

    var _ = this;

    if (_.$dots !== null) {

      _.$dots.find('li').removeClass('slick-active');
      _.$dots.find('li:eq(' + Math.floor(_.currentSlide / _.options.slidesToScroll) + ')').addClass('slick-active');

    }

  };

  $.fn.slick = function (options) {
    var _ = this;
    return _.each(function (index, element) {

      element.slick = new Slick(element, options);

    });
  };

  $.fn.slickAdd = function (slide, slideIndex, addBefore) {
    var _ = this;
    return _.each(function (index, element) {

      element.slick.addSlide(slide, slideIndex, addBefore);

    });
  };

  $.fn.slickCurrentSlide = function () {
    var _ = this;
    return _.get(0).slick.getCurrent();
  };

  $.fn.slickFilter = function (filter) {
    var _ = this;
    return _.each(function (index, element) {

      element.slick.filterSlides(filter);

    });
  };

  $.fn.slickGoTo = function (slide, dontAnimate) {
    var _ = this;
    return _.each(function (index, element) {

      element.slick.changeSlide({
        data: {
          message: 'index',
          index: parseInt(slide)
        }
      }, dontAnimate);

    });
  };

  $.fn.slickNext = function () {
    var _ = this;
    return _.each(function (index, element) {

      element.slick.changeSlide({
        data: {
          message: 'next'
        }
      });

    });
  };

  $.fn.slickPause = function () {
    var _ = this;
    return _.each(function (index, element) {

      element.slick.autoPlayClear();
      element.slick.paused = true;

    });
  };

  $.fn.slickPlay = function () {
    var _ = this;
    return _.each(function (index, element) {

      element.slick.paused = false;
      element.slick.autoPlay();

    });
  };

  $.fn.slickPrev = function () {
    var _ = this;
    return _.each(function (index, element) {

      element.slick.changeSlide({
        data: {
          message: 'previous'
        }
      });

    });
  };

  $.fn.slickRemove = function (slideIndex, removeBefore) {
    var _ = this;
    return _.each(function (index, element) {

      element.slick.removeSlide(slideIndex, removeBefore);

    });
  };

  $.fn.slickRemoveAll = function () {
    var _ = this;
    return _.each(function (index, element) {

      element.slick.removeSlide(null, null, true);

    });
  };

  $.fn.slickGetOption = function (option) {
    var _ = this;
    return _.get(0).slick.options[option];
  };

  $.fn.slickSetOption = function (option, value, refresh) {
    var _ = this;
    return _.each(function (index, element) {

      element.slick.options[option] = value;

      if (refresh === true) {
        element.slick.unload();
        element.slick.reinit();
      }

    });
  };

  $.fn.slickUnfilter = function () {
    var _ = this;
    return _.each(function (index, element) {

      element.slick.unfilterSlides();

    });
  };

  $.fn.unslick = function () {
    var _ = this;
    return _.each(function (index, element) {

      if (element.slick) {
        element.slick.destroy();
      }

    });
  };

  $.fn.getSlick = function () {
    var s = null;
    var _ = this;
    _.each(function (index, element) {
      s = element.slick;
    });

    return s;
  };

}));

(function ($) {
"use strict";

  // Auto loading
  $(window)
    .on('load', function () {
      $('.slick-carousel').each(function () {
        $(this).slick($(this).data('settings'));
      });
    });

})(window.jQuery);;